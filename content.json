{"meta":{"title":"Innovation Louke","subtitle":"Welcome Strangers","description":null,"author":"InnovationLou","url":"https://blog.innnovation.cn","root":"/"},"pages":[{"title":"404","date":"2021-06-08T02:59:13.000Z","updated":"2021-06-08T02:59:40.297Z","comments":true,"path":"404/index.html","permalink":"https://blog.innnovation.cn/404/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-06-07T08:09:54.964Z","updated":"2021-06-07T08:09:54.964Z","comments":true,"path":"categories/index.html","permalink":"https://blog.innnovation.cn/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-06-07T08:11:58.671Z","updated":"2021-06-07T08:11:58.671Z","comments":true,"path":"about/index.html","permalink":"https://blog.innnovation.cn/about/index.html","excerpt":"","text":""},{"title":"movies","date":"2021-06-08T03:29:11.000Z","updated":"2021-06-08T03:29:11.453Z","comments":true,"path":"movies/index.html","permalink":"https://blog.innnovation.cn/movies/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-06-08T04:07:10.803Z","updated":"2021-06-08T04:07:10.803Z","comments":true,"path":"galleries/index.html","permalink":"https://blog.innnovation.cn/galleries/index.html","excerpt":"","text":"123123123test"},{"title":"music","date":"2021-06-08T03:29:00.000Z","updated":"2021-06-08T03:29:00.579Z","comments":true,"path":"music/index.html","permalink":"https://blog.innnovation.cn/music/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-06-07T08:09:15.925Z","updated":"2021-06-07T08:09:15.925Z","comments":true,"path":"tags/index.html","permalink":"https://blog.innnovation.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"webFlux及相关知识点理解和学习","slug":"WebFlux学习及原理性理解","date":"2021-07-09T16:00:00.000Z","updated":"2021-07-10T14:55:20.668Z","comments":true,"path":"2021/07/10/webflux-xue-xi-ji-yuan-li-xing-li-jie/","link":"","permalink":"https://blog.innnovation.cn/2021/07/10/webflux-xue-xi-ji-yuan-li-xing-li-jie/","excerpt":"","text":"本人英语渣渣，但是学习较新的知识还是选择外面的世界多看看，某度的引擎真的是毒瘤，本文概念和词汇可能包含机翻部分，欢迎大神们批评指针 Quote:https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-new-framework 我们先看看Spring为什么要创造WebFlux: Part of the answer is the need for a non-blocking web stack to handle concurrency with a small number of threads and scale with fewer hardware resources. Servlet 3.1 did provide an API for non-blocking I/O. However, using it leads away from the rest of the Servlet API, where contracts are synchronous (Filter, Servlet) or blocking (getParameter, getPart). This was the motivation for a new common API to serve as a foundation across any non-blocking runtime. That is important because of servers (such as Netty) that are well-established in the async, non-blocking space. The other part of the answer is functional programming. Much as the addition of annotations in Java 5 created opportunities (such as annotated REST controllers or unit tests), the addition of lambda expressions in Java 8 created opportunities for functional APIs in Java. This is a boon for non-blocking applications and continuation-style APIs (as popularized by CompletableFuture and ReactiveX) that allow declarative composition of asynchronous logic. At the programming-model level, Java 8 enabled Spring WebFlux to offer functional web endpoints alongside annotated controllers. 总结一下： 需要一个非阻塞的Web技术栈来处理具有少量线程的并发并使用较少的硬件资源进行扩展，Servlet3.1之后提供了NIO非阻塞式API以及Netty都提供了支持 Java的函数式编程（functional programming）支持，lambda表达式提供了函数式API，允许异步逻辑的声明式组合的非阻塞应用程序 那么所以学习WebFlux之前必须了解两个东西lambda、Stream lambda和流API都是Java8才有的（21年3.16JDK16发布），这里就不对lambda和Stream的使用做介绍了，我们主要研究一下实现原理 lambda实现原理初看lambda表达式，感觉就是一个匿名函数（类比匿名内部类），所以我推测当时出这个功能就是Java程序员发现Java只能传递对象，没办法传递函数，大致的使用场景可能是这样的 static void executeFunc(函数引用,String word) &#123; // todo 用传入的方法打印word变量 &#125; 这段代码要是换成C来，只要往这个方法传入一个函数指针即可（函数入口地址） void printWord(char* str);//声明函数 ... void (*fun_ptr)(char*);//定义函数指针 fun_ptr=printWord;//把printWord函数地址赋值给fun_ptr (*fun_ptr)(\"Hello World!\");//直接调用 another_func(fun_ptr,\"Hello World\");//间接调用，回调函数就是用这种方式实现的 那么Java怎么办解决这个问题呢，前面提到了匿名内部类，lambda最初开发的时候可能真的是从这里启发来的，用一个接口(匿名类的父类接口)包裹住这个方法，传接口对象进去就可以了。 为了研究这个问题 上代码，用反编译工具查看底层字节码研究原理 package main; interface Wrapper &#123; void myPrint(String w); &#125; class Solution &#123; static void executeFunc(Wrapper w, String word) &#123; w.myPrint(word); &#125; public static void main(String[] args) &#123; // 匿名内部类写法 executeFunc(new Wrapper() &#123; @Override public void myPrint(String w) &#123; // 个性化拓展，例如在打印之前记录时间什么的 System.out.println(w); &#125; &#125;, \"Hello Lambda!\"); // lambda写法 executeFunc(w -> &#123; // 个性化拓展，例如在打印之前记录时间什么的 System.out.println(w); &#125;, \"Hello Lambda!\"); &#125; &#125; 我们看lambda这部分的字节码 // class version 55.0 (55) // access flags 0x20 class main/Solution &#123; // compiled from: Solution.java // access flags 0x19 public final static INNERCLASS java/lang/invoke/MethodHandles$Lookup java/lang/invoke/MethodHandles Lookup // access flags 0x0 &lt;init>()V L0 LINENUMBER 8 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.&lt;init> ()V RETURN L1 LOCALVARIABLE this Lmain/Solution; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x8 static executeFunc(Lmain/Wrapper;Ljava/lang/String;)V L0 LINENUMBER 11 L0 ALOAD 0 ALOAD 1 INVOKEINTERFACE main/Wrapper.myPrint (Ljava/lang/String;)V (itf) L1 LINENUMBER 12 L1 RETURN L2 LOCALVARIABLE w Lmain/Wrapper; L0 L2 0 LOCALVARIABLE word Ljava/lang/String; L0 L2 1 MAXSTACK = 2 MAXLOCALS = 2 // access flags 0x9 public static main([Ljava/lang/String;)V L0 LINENUMBER 26 L0 INVOKEDYNAMIC myPrint()Lmain/Wrapper; [ // handle kind 0x6 : INVOKESTATIC java/lang/invoke/LambdaMetafactory.metafactory(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite; // arguments: (Ljava/lang/String;)V, // handle kind 0x6 : INVOKESTATIC main/Solution.lambda$main$0(Ljava/lang/String;)V, (Ljava/lang/String;)V ] LDC \"Hello Lambda!\" INVOKESTATIC main/Solution.executeFunc (Lmain/Wrapper;Ljava/lang/String;)V L1 LINENUMBER 31 L1 RETURN L2 LOCALVARIABLE args [Ljava/lang/String; L0 L2 0 MAXSTACK = 2 MAXLOCALS = 1 // access flags 0x100A private static synthetic lambda$main$0(Ljava/lang/String;)V L0 LINENUMBER 28 L0 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ALOAD 0 INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L1 LINENUMBER 29 L1 RETURN L2 LOCALVARIABLE w Ljava/lang/String; L0 L2 0 MAXSTACK = 2 MAXLOCALS = 1 &#125; 注意一行代码 private static synthetic lambda$main$0(Ljava/lang/String;)V//line 61 synthetic这个词的意思是“人造的; (人工)合成的; 综合(型)的”，作为关键字，它表示该方法由编译器自动生成。简言之，把它当做void，这是一个无返回值的静态方法，叫lambda$main$0，接受一个String类型的参数。里面又有一系列操作 编译器把我们写的lambda表达式转换成了一个静态的私有函数，通过调用这个函数来解决传递一段代码的问题 那么还剩下一个问题，JVM是通过什么知道如何执行该私有函数呢，这就得翻阅Oracle官方文档的The invokedynamic Instruction章节 INVOKEDYNAMIC指令，顾名思义，就是动态激活。那这个动态是怎么理解的？这里的”动态”意思是，在运行时才确定，这个调用lambda函数的下一步指向哪里。在初始状态（程序编译成字节码后但未运行时），这个标记是空的，不会执行任何动作。当程序开始执行时，具体一点就是发生字节码的43行，初始化就开始了。在运行时确定，无外乎反射，仔细看43行的一大串包，也确实是通过反射实现的 Stream实现原理先上一张copy的速查表格 Stream操作分类 中间操作(Intermediate operations) 无状态(Stateless) unordered() filter() map() mapToInt() mapToLong() mapToDouble() flatMap() flatMapToInt() flatMapToLong() flatMapToDouble() peek() 有状态(Stateful) distinct() sorted() sorted() limit() skip() 结束操作(Terminal operations) 非短路操作 forEach() forEachOrdered() toArray() reduce() collect() max() min() count() 短路操作(short-circuiting) anyMatch() allMatch() noneMatch() findFirst() findAny() 原理解释引用自:https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/6-Stream%20Pipelines.md &gt;&gt; 操作如何记录 注意这里使用的是“操作(operation)”一词，指的是“Stream中间操作”的操作，很多Stream操作会需要一个回调函数（Lambda表达式），因此一个完整的操作是&lt;*数据来源，操作，回调函数*&gt;构成的三元组。Stream中使用Stage的概念来描述一个完整的操作，并用某种实例化后的PipelineHelper来代表Stage，将具有先后顺序的各个Stage连到一起，就构成了整个流水线。跟Stream相关类和接口的继承关系图示。 还有IntPipeline, LongPipeline, DoublePipeline没在图中画出，这三个类专门为三种基本类型（不是包装类型）而定制的，跟ReferencePipeline是并列关系。图中Head用于表示第一个Stage，即调用调用诸如Collection.stream()*方法产生的Stage，很显然这个Stage里不包含任何操作；*StatelessOp*和*StatefulOp分别表示无状态和有状态的Stage，对应于无状态和有状态的中间操作。 Stream流水线组织结构示意图如下： 图中通过Collection.stream()方法得到Head也就是stage0，紧接着调用一系列的中间操作，不断产生新的Stream。这些Stream对象以双向链表的形式组织在一起，构成整个流水线，由于每个Stage都记录了前一个Stage和本次的操作以及回调函数，依靠这种结构就能建立起对数据源的所有操作。这就是Stream记录操作的方式。 &gt;&gt; 操作如何叠加以上只是解决了操作记录的问题，要想让流水线起到应有的作用我们需要一种将所有操作叠加到一起的方案。你可能会觉得这很简单，只需要从流水线的head开始依次执行每一步的操作（包括回调函数）就行了。这听起来似乎是可行的，但是你忽略了前面的Stage并不知道后面Stage到底执行了哪种操作，以及回调函数是哪种形式。换句话说，只有当前Stage本身才知道该如何执行自己包含的动作。这就需要有某种协议来协调相邻Stage之间的调用关系。 这种协议由Sink接口完成，Sink接口包含的方法如下表所示： 方法名 作用 void begin(long size) 开始遍历元素之前调用该方法，通知Sink做好准备。 void end() 所有元素遍历完成之后调用，通知Sink没有更多的元素了。 boolean cancellationRequested() 是否可以结束操作，可以让短路操作尽早结束。 void accept(T t) 遍历元素时调用，接受一个待处理元素，并对元素进行处理。Stage把自己包含的操作和回调方法封装到该方法里，前一个Stage只需要调用当前Stage.accept(T t)方法就行了。 有了上面的协议，相邻Stage之间调用就很方便了，每个Stage都会将自己的操作封装到一个Sink里，前一个Stage只需调用后一个Stage的accept()方法即可，并不需要知道其内部是如何处理的。当然对于有状态的操作，Sink的begin()和end()方法也是必须实现的。比如Stream.sorted()是一个有状态的中间操作，其对应的Sink.begin()方法可能创建一个盛放结果的容器，而accept()方法负责将元素添加到该容器，最后end()负责对容器进行排序。对于短路操作，Sink.cancellationRequested()也是必须实现的，比如Stream.findFirst()是短路操作，只要找到一个元素，cancellationRequested()就应该返回true，以便调用者尽快结束查找。Sink的四个接口方法常常相互协作，共同完成计算任务。实际上Stream API内部实现的的本质，就是如何重写Sink的这四个接口方法。 有了Sink对操作的包装，Stage之间的调用问题就解决了，执行时只需要从流水线的head开始对数据源依次调用每个Stage对应的Sink.{begin(), accept(), cancellationRequested(), end()}方法就可以了。一种可能的Sink.accept()方法流程是这样的： void accept(U u)&#123; 1. 使用当前Sink包装的回调函数处理u 2. 将处理结果传递给流水线下游的Sink &#125; Sink接口的其他几个方法也是按照这种[处理-&gt;转发]的模型实现。下面我们结合具体例子看看Stream的中间操作是如何将自身的操作包装成Sink以及Sink是如何将处理结果转发给下一个Sink的。先看Stream.map()方法： &#x2F;&#x2F; Stream.map()，调用该方法将产生一个新的Stream public final &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super P_OUT, ? extends R&gt; mapper) &#123; ... return new StatelessOp&lt;P_OUT, R&gt;(this, StreamShape.REFERENCE, StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123; @Override &#x2F;*opWripSink()方法返回由回调函数包装而成Sink*&#x2F; Sink&lt;P_OUT&gt; opWrapSink(int flags, Sink&lt;R&gt; downstream) &#123; return new Sink.ChainedReference&lt;P_OUT, R&gt;(downstream) &#123; @Override public void accept(P_OUT u) &#123; R r &#x3D; mapper.apply(u);&#x2F;&#x2F; 1. 使用当前Sink包装的回调函数mapper处理u downstream.accept(r);&#x2F;&#x2F; 2. 将处理结果传递给流水线下游的Sink &#125; &#125;; &#125; &#125;; &#125; 上述代码看似复杂，其实逻辑很简单，就是将回调函数mapper包装到一个Sink当中。由于Stream.map()是一个无状态的中间操作，所以map()方法返回了一个StatelessOp内部类对象（一个新的Stream），调用这个新Stream的opWripSink()方法将得到一个包装了当前回调函数的Sink。 再来看一个复杂一点的例子。Stream.sorted()方法将对Stream中的元素进行排序，显然这是一个有状态的中间操作，因为读取所有元素之前是没法得到最终顺序的。抛开模板代码直接进入问题本质，sorted()方法是如何将操作封装成Sink的呢？sorted()一种可能封装的Sink代码如下： &#x2F;&#x2F; Stream.sort()方法用到的Sink实现 class RefSortingSink&lt;T&gt; extends AbstractRefSortingSink&lt;T&gt; &#123; private ArrayList&lt;T&gt; list;&#x2F;&#x2F; 存放用于排序的元素 RefSortingSink(Sink&lt;? super T&gt; downstream, Comparator&lt;? super T&gt; comparator) &#123; super(downstream, comparator); &#125; @Override public void begin(long size) &#123; ... &#x2F;&#x2F; 创建一个存放排序元素的列表 list &#x3D; (size &gt;&#x3D; 0) ? new ArrayList&lt;T&gt;((int) size) : new ArrayList&lt;T&gt;(); &#125; @Override public void end() &#123; list.sort(comparator);&#x2F;&#x2F; 只有元素全部接收之后才能开始排序 downstream.begin(list.size()); if (!cancellationWasRequested) &#123;&#x2F;&#x2F; 下游Sink不包含短路操作 list.forEach(downstream::accept);&#x2F;&#x2F; 2. 将处理结果传递给流水线下游的Sink &#125; else &#123;&#x2F;&#x2F; 下游Sink包含短路操作 for (T t : list) &#123;&#x2F;&#x2F; 每次都调用cancellationRequested()询问是否可以结束处理。 if (downstream.cancellationRequested()) break; downstream.accept(t);&#x2F;&#x2F; 2. 将处理结果传递给流水线下游的Sink &#125; &#125; downstream.end(); list &#x3D; null; &#125; @Override public void accept(T t) &#123; list.add(t);&#x2F;&#x2F; 1. 使用当前Sink包装动作处理t，只是简单的将元素添加到中间列表当中 &#125; &#125; 上述代码完美的展现了Sink的四个接口方法是如何协同工作的： 首先begin()方法告诉Sink参与排序的元素个数，方便确定中间结果容器的的大小； 之后通过accept()方法将元素添加到中间结果当中，最终执行时调用者会不断调用该方法，直到遍历所有元素； 最后end()方法告诉Sink所有元素遍历完毕，启动排序步骤，排序完成后将结果传递给下游的Sink； 如果下游的Sink是短路操作，将结果传递给下游时不断询问下游cancellationRequested()是否可以结束处理。 &gt;&gt; 叠加之后的操作如何执行 Sink完美封装了Stream每一步操作，并给出了[处理-&gt;转发]的模式来叠加操作。这一连串的齿轮已经咬合，就差最后一步拨动齿轮启动执行。是什么启动这一连串的操作呢？也许你已经想到了启动的原始动力就是结束操作(Terminal Operation)，一旦调用某个结束操作，就会触发整个流水线的执行。 结束操作之后不能再有别的操作，所以结束操作不会创建新的流水线阶段(Stage)，直观的说就是流水线的链表不会在往后延伸了。结束操作会创建一个包装了自己操作的Sink，这也是流水线中最后一个Sink，这个Sink只需要处理数据而不需要将结果传递给下游的Sink（因为没有下游）。对于Sink的[处理-&gt;转发]模型，结束操作的Sink就是调用链的出口。 我们再来考察一下上游的Sink是如何找到下游Sink的。一种可选的方案是在PipelineHelper中设置一个Sink字段，在流水线中找到下游Stage并访问Sink字段即可。但Stream类库的设计者没有这么做，而是设置了一个Sink AbstractPipeline.opWrapSink(int flags, Sink downstream)方法来得到Sink，该方法的作用是返回一个新的包含了当前Stage代表的操作以及能够将结果传递给downstream的Sink对象。为什么要产生一个新对象而不是返回一个Sink字段？这是因为使用opWrapSink()可以将当前操作与下游Sink（上文中的downstream参数）结合成新Sink。试想只要从流水线的最后一个Stage开始，不断调用上一个Stage的opWrapSink()方法直到最开始（不包括stage0，因为stage0代表数据源，不包含操作），就可以得到一个代表了流水线上所有操作的Sink，用代码表示就是这样： &#x2F;&#x2F; AbstractPipeline.wrapSink() &#x2F;&#x2F; 从下游向上游不断包装Sink。如果最初传入的sink代表结束操作， &#x2F;&#x2F; 函数返回时就可以得到一个代表了流水线上所有操作的Sink。 final &lt;P_IN&gt; Sink&lt;P_IN&gt; wrapSink(Sink&lt;E_OUT&gt; sink) &#123; ... for (AbstractPipeline p&#x3D;AbstractPipeline.this; p.depth &gt; 0; p&#x3D;p.previousStage) &#123; sink &#x3D; p.opWrapSink(p.previousStage.combinedFlags, sink); &#125; return (Sink&lt;P_IN&gt;) sink; &#125; 现在流水线上从开始到结束的所有的操作都被包装到了一个Sink里，执行这个Sink就相当于执行整个流水线，执行Sink的代码如下： &#x2F;&#x2F; AbstractPipeline.copyInto(), 对spliterator代表的数据执行wrappedSink代表的操作。 final &lt;P_IN&gt; void copyInto(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator) &#123; ... if (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123; wrappedSink.begin(spliterator.getExactSizeIfKnown());&#x2F;&#x2F; 通知开始遍历 spliterator.forEachRemaining(wrappedSink);&#x2F;&#x2F; 迭代 wrappedSink.end();&#x2F;&#x2F; 通知遍历结束 &#125; ... &#125; 上述代码首先调用wrappedSink.begin()方法告诉Sink数据即将到来，然后调用spliterator.forEachRemaining()方法对数据进行迭代（Spliterator是容器的一种迭代器，[参阅](https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/3-Lambda and Collections.md#spliterator)），最后调用wrappedSink.end()方法通知Sink数据处理结束。逻辑如此清晰。 &gt;&gt; 执行后的结果在哪里最后一个问题是流水线上所有操作都执行后，用户所需要的结果（如果有）在哪里？首先要说明的是不是所有的Stream结束操作都需要返回结果，有些操作只是为了使用其副作用(Side-effects)，比如使用Stream.forEach()方法将结果打印出来就是常见的使用副作用的场景（事实上，除了打印之外其他场景都应避免使用副作用），对于真正需要返回结果的结束操作结果存在哪里呢？ 特别说明：副作用不应该被滥用，也许你会觉得在Stream.forEach()里进行元素收集是个不错的选择，就像下面代码中那样，但遗憾的是这样使用的正确性和效率都无法保证，因为Stream可能会并行执行。大多数使用副作用的地方都可以使用[归约操作](https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/5-Streams API(II).md)更安全和有效的完成。 &#x2F;&#x2F; 错误的收集方式 ArrayList&lt;String&gt; results &#x3D; new ArrayList&lt;&gt;(); stream.filter(s -&gt; pattern.matcher(s).matches()) .forEach(s -&gt; results.add(s)); &#x2F;&#x2F; Unnecessary use of side-effects! &#x2F;&#x2F; 正确的收集方式 List&lt;String&gt;results &#x3D; stream.filter(s -&gt; pattern.matcher(s).matches()) .collect(Collectors.toList()); &#x2F;&#x2F; No side-effects! 回到流水线执行结果的问题上来，需要返回结果的流水线结果存在哪里呢？这要分不同的情况讨论，下表给出了各种有返回结果的Stream结束操作。 返回类型 对应的结束操作 boolean anyMatch() allMatch() noneMatch() Optional findFirst() findAny() 归约结果 reduce() collect() 数组 toArray() 对于表中返回boolean或者Optional的操作（Optional是存放 一个 值的容器）的操作，由于值返回一个值，只需要在对应的Sink中记录这个值，等到执行结束时返回就可以了。 对于归约操作，最终结果放在用户调用时指定的容器中（容器类型通过[收集器](https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/5-Streams API(II).md#收集器)指定）。collect(), reduce(), max(), min()都是归约操作，虽然max()和min()也是返回一个Optional，但事实上底层是通过调用[reduce()](https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/5-Streams API(II).md#多面手reduce)方法实现的。 对于返回是数组的情况，毫无疑问的结果会放在数组当中。这么说当然是对的，但在最终返回数组之前，结果其实是存储在一种叫做Node的数据结构中的。Node是一种多叉树结构，元素存储在树的叶子当中，并且一个叶子节点可以存放多个元素。这样做是为了并行执行方便。关于Node的具体结构，我们会在下一节探究Stream如何并行执行时给出详细说明。 我们直接举个栗子 List&lt;String> data = new ArrayList&lt;>(); data.add(\"张三\"); data.add(\"李四\"); data.add(\"王三\"); data.add(\"马六\"); data.stream() .filter(x -> x.length() == 2) .map(x -> x.replace(\"三\",\"五\")) .sorted() .filter(x -> x.contains(\"五\")) .forEach(System.out::println); 操作是如何记录下来的? Head记录Stream起始操作 StatelessOp记录中间操作 StatefulOp记录有状态的中间操作这三个操作实例化会指向其父类AbstractPipeline,也就是在AbstractPipeline中建立了双向链表 对于Head AbstractPipeline(Spliterator&lt;?> source, int sourceFlags, boolean parallel) &#123; this.previousStage = null; //首操作上一步为null this.sourceSpliterator = source; //数据 this.sourceStage = this; //Head操作 this.sourceOrOpFlags = sourceFlags &amp; StreamOpFlag.STREAM_MASK; this.combinedFlags = (~(sourceOrOpFlags &lt;&lt; 1)) &amp; StreamOpFlag.INITIAL_OPS_VALUE; this.depth = 0; this.parallel = parallel; &#125; 对于其他Stage: AbstractPipeline(AbstractPipeline&lt;?, E_IN, ?> previousStage, int opFlags) &#123; if (previousStage.linkedOrConsumed) throw new IllegalStateException(MSG_STREAM_LINKED); previousStage.linkedOrConsumed = true; //双向链表的建立 previousStage.nextStage = this; this.previousStage = previousStage; this.sourceStage = previousStage.sourceStage; this.depth = previousStage.depth + 1; this.sourceOrOpFlags = opFlags &amp; StreamOpFlag.OP_MASK; this.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags); if (opIsStateful()) sourceStage.sourceAnyStateful = true; &#125; 调用过程如此用双向链表串联起来,每一步都得知其上一步与下一步的操作. data.stream() .filter(x -> x.length() == 2) .map(x -> x.replace(“三”,”五”)) .sorted() .filter(x -> x.contains(“五”)) .forEach(System.out::println); 操作是如何叠加的? Sink&lt;T&gt;接口: void begin(long size),循环开始前调用,通知每个Stage做好准备 void end(),循环结束时调用,依次调用每个Stage的end方法,处理结果 boolean cancellationRequested(),判断是否可以提前结束循环 void accept(T value),每一步的处理 其子类之一ChainedReference: static abstract class ChainedReference&lt;T, E_OUT> implements Sink&lt;T> &#123; protected final Sink&lt;? super E_OUT> downstream; public ChainedReference(Sink&lt;? super E_OUT> downstream) &#123; this.downstream = Objects.requireNonNull(downstream); &#125; @Override public void begin(long size) &#123; downstream.begin(size); &#125; @Override public void end() &#123; downstream.end(); &#125; @Override public boolean cancellationRequested() &#123; return downstream.cancellationRequested(); &#125; &#125; 例Filter: @Override public final Stream&lt;P_OUT> filter(Predicate&lt;? super P_OUT> predicate) &#123; Objects.requireNonNull(predicate); return new StatelessOp&lt;P_OUT, P_OUT>(this, StreamShape.REFERENCE, StreamOpFlag.NOT_SIZED) &#123; @Override Sink&lt;P_OUT> opWrapSink(int flags, Sink&lt;P_OUT> sink) &#123; return new Sink.ChainedReference&lt;P_OUT, P_OUT>(sink) &#123; @Override public void begin(long size) &#123; downstream.begin(-1); &#125; @Override public void accept(P_OUT u) &#123; //条件成立则传递给下一个操作,也因为如此所以有状态的操作必须放到 //end方法里面 if (predicate.test(u)) downstream.accept(u); &#125; &#125;; &#125; &#125;; &#125; 再例如sorted(): @Override public void begin(long size) &#123; if (size >= Nodes.MAX_ARRAY_SIZE) throw new IllegalArgumentException(Nodes.BAD_SIZE); list = (size >= 0) ? new ArrayList&lt;T>((int) size) : new ArrayList&lt;T>(); &#125; @Override public void end() &#123; list.sort(comparator); downstream.begin(list.size()); if (!cancellationWasRequested) &#123; list.forEach(downstream::accept); &#125; else &#123; for (T t : list) &#123; if (downstream.cancellationRequested()) break; downstream.accept(t); &#125; &#125; downstream.end(); list = null; &#125; @Override public void accept(T t) &#123; list.add(t); &#125; 叠加后如何执行? 执行操作是由终端操作来触发的,例如foreach操作 @Override public void forEach(Consumer&lt;? super P_OUT> action) &#123; //evaluate就是开关,一旦调用就立即执行整个Stream evaluate(ForEachOps.makeRef(action, false)); &#125; 执行前会对操作从末尾到起始反向包裹起来,得到调用链 Sink opWrapSink(int flags, Sink&lt;P_OUT> sink) ; //这个Sink是终端操作所对应的Sink final &lt;P_IN> Sink&lt;P_IN> wrapSink(Sink&lt;E_OUT> sink) &#123; Objects.requireNonNull(sink); for ( AbstractPipeline p=AbstractPipeline.this; p.depth > 0; p=p.previousStage) &#123; sink = p.opWrapSink(p.previousStage.combinedFlags, sink); &#125; return (Sink&lt;P_IN>) sink; &#125; @Override final &lt;P_IN> void copyInto(Sink&lt;P_IN> wrappedSink, Spliterator&lt;P_IN> spliterator) &#123; Objects.requireNonNull(wrappedSink); if (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123; //依次执行调用链 wrappedSink.begin(spliterator.getExactSizeIfKnown()); spliterator.forEachRemaining(wrappedSink); wrappedSink.end(); &#125; else &#123; copyIntoWithCancel(wrappedSink, spliterator); &#125; &#125; 有状态的中间操作何时执行? 例如sorted()操作,其依赖上一次操作的结果集,按照调用链来说结果集必须在accept()调用完才会产生.那也就说明sorted操作需要在end中,然后再重新开启调用链. sorted的end方法: @Override public void end() &#123; list.sort(comparator); downstream.begin(list.size()); if (!cancellationWasRequested) &#123; list.forEach(downstream::accept); &#125; else &#123; for (T t : list) &#123; if (downstream.cancellationRequested()) break; downstream.accept(t); &#125; &#125; downstream.end(); list = null; &#125; 那么就相当于sorted给原有操作断路了一次,然后又重新接上,再次遍历. 如何收集到结果? foreach是不需要收集到结果的,但是对于collect这样的操作是需要拿到最终end产生的结果.end产生的结果在最后一个Sink中,这样的操作最终都会提供一个取出数据的get方法. @Override public &lt;P_IN> R evaluateSequential(PipelineHelper&lt;T> helper, Spliterator&lt;P_IN> spliterator) &#123; return helper.wrapAndCopyInto(makeSink(), spliterator).get(); &#125; WebFlux终于到了我们的主角WebFlux，阅读官网文档会发现有这些单词 We touched on “non-blocking” and “functional” but what does reactive mean? The term, “reactive,” refers to programming models that are built around reacting to change — network components reacting to I/O events, UI controllers reacting to mouse events, and others. In that sense, non-blocking is reactive, because, instead of being blocked, we are now in the mode of reacting to notifications as operations complete or data becomes available. There is also another important mechanism that we on the Spring team associate with “reactive” and that is non-blocking back pressure. In synchronous, imperative code, blocking calls serve as a natural form of back pressure that forces the caller to wait. In non-blocking code, it becomes important to control the rate of events so that a fast producer does not overwhelm its destination. 其中有几个关键词：响应式、异步非阻塞、背压。这就是WebFlux的概念核心 先上图 WebFlux模型主要依赖响应式编程库Reactor，Reactor 有两种模型，Flux 和 Mono，提供了非阻塞、支持回压机制的异步流处理能力。WebFlux API接收普通Publisher作为输入，在内部使其适配Reactor类型，使用它并返回Flux或Mono作为输出。 我们平时开发过程中只要在Controller中控制每个接口的Publisher入参和Mono返回值(web项目用mono比较多吧)就可以顺利使用WebFlux框架完成业务，并不需要关注黑盒中的东西。 上图中我们主要到从Http客户端到Spring Controller到Service到数据库之间所有的请求全部是Flux，即全部是异步非阻塞，如果一个系统完全遵守Flux的模型开发，将会大大提高系统的吞吐量，比如Mybatis、JDBC等技术将不推荐使用，因为他们本质都是同步操作，这样还是会使得请求在最后的同步IO管线上堆积。对于底层的数据源来说，MongoDB, Redis, 和 Cassandra 可以直接以reactive的方式支持Spring Data。 我整理了一张反应式组件的图 其中JDK9的响应式流其实本质上完全跟JDK8的同步流不是一个东西，Project Reactor其实就是根据JDK9响应流接口做的1：1设计，可以自己查看JDK9的源码就可以得到相关的接口信息。","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.innnovation.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.innnovation.cn/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.innnovation.cn/tags/Spring/"},{"name":"WebFlux","slug":"WebFlux","permalink":"https://blog.innnovation.cn/tags/WebFlux/"}]},{"title":"git复习进阶及命令速查","slug":"git使用复习进阶速查手册","date":"2021-07-06T16:00:00.000Z","updated":"2021-07-08T01:58:47.306Z","comments":true,"path":"2021/07/07/git-shi-yong-fu-xi-jin-jie-su-cha-shou-ce/","link":"","permalink":"https://blog.innnovation.cn/2021/07/07/git-shi-yong-fu-xi-jin-jie-su-cha-shou-ce/","excerpt":"","text":"原理主要操作流程图 基本原理版本控制系统主要分为中央式和分布式 中央式：将代码保存在中央服务器，加入编码的成员均与服务器通讯，在本地完成代码，上传/同步他人代码，代码由服务器统一管理 分布式：所有参与开发的人员都维护自己的本地仓库，对自己本地仓库提交切换分支等操作均在本地完成，远程仓库由仓库管理员管理分配权限，本地仓库和远程仓库有时候会各自维护自己的分支，而远程仓库更多只是起到团队同步代码的作用 git本地存在：本地仓库，暂存区和工作目录，git init时所在的目录就是工作目录，暂存区和本地仓库都存在.git隐藏文件中。 git文件有两种状态：是否被跟踪，未被跟踪的文件就和资源文件管理器中的普通文件一样，可以随意修改删除，但是被git add 添加到git追踪的文件本地仓库就会对他们负责，通过git status查看他们的状态来进行相应的操作。 一个项目中的gitignore文件指定了git要忽略的文件类型而不追踪他们。 前面所提到的暂存区是当我们在工作目录中进行文件操作时，要先添加到暂存区，然后再将暂存区中的文件快照提交到本地仓库，这样就实现了各个快照之间可以随意的进行回滚操作。 git对象从git设计者角度考虑，git存在一套内容寻址的文件系统，本质上是K-V键值对，通过key找value，从源码层面看，git将指针保存在git对象中，根据指针来找到需要的文件内容。git对象分为：commit tree blob对象。 commit结构体包含 tree_ptr,parent_ptr,author,time … tree结构记录文件列表list 每个文件的内容为blob commit对象记录每次提交到本地快照，每次提交一个就会让上一个commit对象指向新的commit（本质就是一个链表），当我们进行恢复commit操作时，就通过id来找到我们需要恢复的commit节点即可。而HEAD对象其实就是指向最近一个提交的commit，也就是最后一个commit 引用（分支）在使用git log 命令时我们会看到一些HEAD-&gt;master,origin/master,origin/HEAD等字样，他们本质上就是指向commit的引用，如果理解了前面的commit对象，就知道引用其实就是该对象名的一个别名（可以简单理解为C++的引用） 如果你想在某处创建 branch ，只需要输入一行 git branch 名称 切换分支 就是将HEAD指针指向别的分支 切换后同样可以commit新节点 如果你再切换到 master 去 commit，就会真正地出现分叉了 各个commit之间会形成分支树(Tree),任意branch之间都是平等的 任意branch包含的节点一定是从（branch最开始的commit节点）头节点开始的——1234-&gt;12347;1256-&gt;12567 每个commit有一个唯一SHA-1校验码用来区分，用户可以用过他们的引用（名字）来对他们进行操作 HEAD：当前commit引用branch：一个特别的引用，可以被HEAD指向，形象的理解为commit发生时会带着HEAD移动 master/main:默认branch1.新建时 2.clone时 而删除分支时，仅仅是删除引用 push的本质本质就是比较push过来的branch引用，从最后一个相同节点后面接上新的commit节点 push会把当前分支上的commit节点上传到远程库，git push会推送本地的默认分支，不是默认分支时需要git push origin branch_name来指定 远程库的HEAD引用不会因为push而改变，而是随着默认分支移动 merge的本质本质是将两个链表的最后一个节点合并成一个新节点，并让HEAD指向该节点 特殊情况1：冲突merge合并commit时，如果修改了同一个文件，最终导致无法生成一个文件快照，这就是冲突（conflict） 解决方法：解决冲突（修改掉冲突的代码）-&gt;手动commit/取消merge 解决冲突时根据需要删除&lt;&lt;&lt;&lt;&lt; ========== &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这些辅助性字符即可 解决完后 git add shopping\\ list.txt # commit 前也需要先 add 一下 git commit 当然 也可以放弃解决冲突 git merge --abort 特殊情况2：HEAD领先于目标commitgit默认不进行任何操作 特殊情况3：HEAD落后git默认进行fast-forward，将head移动到最近的commit 同样，当发生在本地库和远程库时，下图也正解释了为什么从远程库同步代码时只需要git pull命令即可 git pull=git fetch + git merge(fast-forward) Feature Branching 工作流在最基本的团队工作模型中，所有人都工作在 master 上，写完了的 commit 可以通过 push 来发送到中央仓库，并且可以使用 pull 来获取到别人的最新 commit。这种工作模型解决了团队合作最基本的问题：多人并行开发和版本管理。 但这种工作模型也有它的限制：使用这种工作模型时，每个人的代码在被大家看到的时候，就是它进入正式的生产库的时候。所有人的工作都会被直接 push 到 master，这导致每个人的代码在正式启用前无法被别人看到，这样就让代码在正式启用前的讨论和 review（审阅）非常不方便。现在的商业团队，开发项目多是采用「边开发边发布、边开发边更新、边开发边修复」的持续开发策略，所以代码分享的不便会极大地影响团队的开发效率。 简介工作流的核心内容可以总结为两点： 任何新的功能（feature）或 bug 修复全都新建一个 branch 来写； branch 写完后，合并到 master，然后删掉这个 branch。 运行原理和流程假设团队分配给我一个任务，开发一个新功能books git checkout -b books git push origin books 于是我本地开发完成后push到远程库后产生books分支 然后代码审计人员想要查看我写的怎么样 git pull git chekcout books 如果代码通过审核，于是审计人员同意merge到master git checkout master git pull # merge 之前 pull 一下，让 master 更新到和远程仓库同步 git merge books 最后把合并后的结果 push 到了中央仓库，并删掉了 books 这个 branch 如果代码审核不通过，审计人员通知到我，我只需要在books上面继续修改，然后push，继续回到上面的流程，直到审核通过。 Pull RequestPull Request就是我们常说的PR，这是由Git仓库服务提供方提供的功能，方便团队讨论一个branch，并可以一键合并到master Rebase——在新位置重新提交本质上讲rebase就是将一个子树的根节点移动到另一个节点上，就是改变了他们的（子树）根节点。 git rebase 目标基础点 例： git checkout branch1 git rebase master 可以看出，通过 rebase，5 和 6 两条 commits 把基础点从 2 换成了 4 。通过这样的方式，就让本来分叉了的提交历史重新回到了一条线。这种「重新设置基础点」的操作，就是 rebase 的含义 另外，在 rebase 之后，记得切回 master 再 merge 一下，把 master 移到最新的 commit git checkout master git merge branch1 注意：为了避免和远端仓库发生冲突，一般不要从 master 向其他 branch 执行 rebase 操作。而如果是 master 以外的 branch 之间的 rebase（比如 branch1 和 branch2 之间），就不必这么多费一步，直接 rebase 就好 rebase -i:交互式rebasegit rebase -i HEAD^^ //回到倒数第二个提交 说明：在 Git 中，有两个「偏移符号」： ^ 和 ~。 ^ 的用法：在 commit 的后面加一个或多个 ^ 号，可以把 commit 往回偏移，偏移的数量是 ^ 的数量。例如：master^ 表示 master 指向的 commit 之前的那个 commit； HEAD^^ 表示 HEAD 所指向的 commit 往前数两个 commit。 ~ 的用法：在 commit 的后面加上 ~ 号和一个数，可以把 commit 往回偏移，偏移的数量是 ~ 号后面的数。例如：HEAD~5 表示 HEAD 指向的 commit往前数 5 个 commit。 编辑界面：选择 commit 和对应的操作这两行指示了两个信息： 需要处理哪些 commit； 怎么处理它们。 把 pick 修改成 edit 后，就可以退出编辑界面了： 上图的提示信息说明，rebase 过程已经停在了第二个 commit 的位置，那么现在你就可以去修改你想修改的内容了。 修改完成之后，和上节里的方法一样，用 commit --amend 来把修正应用到当前最新的 commit： git add 笑声 git commit --amend 继续 rebase 过程在修复完成之后，就可以用 rebase --continue 来继续 rebase 过程，把后面的 commit 直接应用上去。 git rebase --continue 然后，这次交互式 rebase 的过程就完美结束了，你的那个倒数第二个写错的 commit 就也被修正了 如果commit已经提交了发现错误，怎么优雅的改掉git commit --amend Git 会把你带到提交信息编辑界面。可以看到，提交信息默认是当前提交的提交信息。你可以修改或者保留它，然后保存退出。然后，你的最新 commit 就被更新了 撤销Commitgit reset --hard 目标commit 通过前面原理可知，节点是不会被删除的，如果还需要，可以记住SHA-1码来找到对应commit git reset --hard HEAD^ 撤销不是最新的commitgit rebase -i HEAD^^ 然后就会跳到 commit 序列的编辑界面，需要修改这个序列来进行操作。不过不同的是，之前修正 commit 的方法是把要修改的 commit 左边的 pick 改成 edit，而如果你要撤销某个 commit ，直接删掉这一行就好。 pick 的直接意思是「选取」，在这个界面的意思就是应用这个 commit。而如果把这一行删掉，那就相当于在 rebase 的过程中跳过了这个 commit，从而也就把这个 commit 撤销掉了。 用 rebase –onto 撤销提交除了用交互式 rebase ，你还可以用 rebase --onto 来更简便地撤销提交。 rebase 加上 --onto 选项之后，可以指定 rebase 的「起点」。一般的 rebase，告诉 Git 的是「我要把当前 commit 以及它之前的 commits 重新提交到目标 commit 上去，这其中，rebase 的「起点」是自动判定的：选取当前 commit 和目标 commit 在历史上的交叉点作为起点。 例如下面这种情况： 如果在这里执行： git rebase 第3个commit 那么 Git 会自动选取 3 和 5 的历史交叉点 2 作为 rebase 的起点，依次将 4 和 5 重新提交到 3 的路径上去。 而 --onto 参数，就可以额外给 rebase 指定它的起点。例如同样以上图为例，如果我只想把 5 提交到 3 上，不想附带上 4，那么我可以执行： git rebase --onto 第3个commit 第4个commit branch1 --onto 参数后面有三个附加参数：目标 commit、起点 commit（注意：rebase 的时候会把起点排除在外）、终点 commit。所以上面这行指令就会从 4 往下数，拿到 branch1 所指向的 5，然后把 5 重新提交到 3 上去。 同样的，你也可以用 rebase --onto 来撤销提交： git rebase --onto HEAD^^ HEAD^ branch1 上面这行代码的意思是：以倒数第二个 commit 为起点（起点不包含在 rebase 序列里哟），branch1 为终点，rebase 到倒数第三个 commit 上。 也就是这样： 代码已经 push 上去了才发现写错？有的时候，代码 push 到了中央仓库，才发现有个 commit 写错了。这种问题的处理分两种情况： 1. 出错的内容在你自己的 branch 由于在本地对已有的 commit 做了修改，这时再 push 就会失败，因为中央仓库包含本地没有的 commit。但这个和前面讲过的情况不同，这次的冲突不是因为同事 push 了新的提交，而是因为你刻意修改了一些内容，这个冲突是你预料到的，你本来就希望用本地的内容覆盖掉中央仓库的内容 git push origin branch1 -f 这样，在本地修改了错误的 commits，然后强制 push 上去，问题解决。 2. 出错的内容已经合并到 master用法很简单，你希望撤销哪个 commit，就把它填在后面： git revert HEAD^ 上面这行代码就会增加一条新的 commit，它的内容和倒数第二个 commit 是相反的，从而和倒数第二个 commit 相互抵消，达到撤销的效果。 在 revert 完成之后，把新的 commit 再 push 上去，这个 commit 的内容就被撤销了。它和前面所介绍的撤销方式相比，最主要的区别是，这次改动只是被「反转」了，并没有在历史中消失掉，你的历史中会存在两条 commit ：一个原始 commit ，一个对它的反转 commit。 分支策略明白了git仓库和分支的概念和操作，下面介绍几种常见开发的分支策略，可以使得版本库的演进保持简洁，主干清晰，各个分支各司其职、井井有条。 主分支Master 首先，代码库应该有一个、且仅有一个主分支。所有提供给用户使用的正式版本，都在这个主分支上发布。 Git主分支的名字，默认叫做Master。它是自动建立的，版本库初始化以后，默认就是在主分支在进行开发。 开发分支Develop 主分支只用来分布重大版本，日常开发应该在另一条分支上完成。我们把开发用的分支，叫做Develop。 这个分支可以用来生成代码的最新隔夜版本（nightly）。如果想正式对外发布，就在Master分支上，对Develop分支进行”合并”（merge）。 临时性分支 前面讲到版本库的两条主要分支：Master和Develop。前者用于正式发布，后者用于日常开发。其实，常设分支只需要这两条就够了，不需要其他了。 但是，除了常设分支以外，还有一些临时性分支，用于应对一些特定目的的版本开发。临时性分支主要有三种： * 功能（feature）分支 * 预发布（release）分支 * 修补bug（fixbug）分支 这三种分支都属于临时性需要，使用完以后，应该删除，使得代码库的常设分支始终只有Master和Develop。 1.功能分支 它是为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop。 功能分支的名字，可以采用feature-*的形式命名。 2.预发布分支 它是指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。 预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支。它的命名，可以采用release-*的形式。 3.修补bug分支 软件正式发布以后，难免会出现bug。这时就需要创建一个分支，进行bug修补。 修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支。它的命名，可以采用fixbug-*的形式。 IDEA操作git操作其实本不在乎用命令行还是界面，关键是理解分支和仓库的本质。新版idea的git操作非常非常方便，在IDE界面的右下角，和项目的右键GIT菜单都可以快捷打开所有常用命令，且均提供可视化操作界面，可谓老少皆宜，idea 永远滴神！ 可以用commit子窗口快速提交 右下角可以快速checkout切换分支 冲突处理界面也异常友好，除了显示两个冲突文件，还会显示前有一次正确提交的文件在中间以供参考 命令速查","categories":[{"name":"杂项","slug":"杂项","permalink":"https://blog.innnovation.cn/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"https://blog.innnovation.cn/tags/%E6%9D%82%E9%A1%B9/"},{"name":"GIT","slug":"GIT","permalink":"https://blog.innnovation.cn/tags/GIT/"}]},{"title":"操作系统-第一个C函数-实现板级初始化","slug":"操作系统-第一个C函数-实现板级初始化","date":"2021-07-04T16:00:00.000Z","updated":"2021-07-08T02:41:44.243Z","comments":true,"path":"2021/07/05/cao-zuo-xi-tong-di-yi-ge-c-han-shu-shi-xian-ban-ji-chu-shi-hua/","link":"","permalink":"https://blog.innnovation.cn/2021/07/05/cao-zuo-xi-tong-di-yi-ge-c-han-shu-shi-xian-ban-ji-chu-shi-hua/","excerpt":"","text":"第一个C函数void hal_start() &#123; //第一步：初始化hal层 //第二步：初始化内核层 for(;;); return; &#125; 死循环避免函数返回 hal层初始化void init_hal() &#123; //初始化平台 //初始化内存 //初始化中断 return; &#125; 初始化平台、初始化内存、初始化中断的功能函数 初始化平台 把二级引导器建立的机器信息结构复制到 hal 层中的一个全局变量中，方便内核中的其它代码使用里面的信息，之后二级引导器建立的数据所占用的内存都会被释放。 要初始化图形显示驱动，内核在运行过程要在屏幕上输出信息 void machbstart_t_init(machbstart_t *initp) &#123; //清零 memset(initp, 0, sizeof(machbstart_t)); return; &#125; void init_machbstart() &#123; machbstart_t *kmbsp = &amp;kmachbsp; machbstart_t *smbsp = MBSPADR;//物理地址1MB处 machbstart_t_init(kmbsp); //复制，要把地址转换成虚拟地址 memcopy((void *)phyadr_to_viradr((adr_t)smbsp), (void *)kmbsp, sizeof(machbstart_t)); return; &#125; //平台初始化函数 void init_halplaltform() &#123; //复制机器信息结构 init_machbstart(); //初始化图形显示驱动 init_bdvideo(); return; &#125; kmachbsp结构体类型是 machbstart_t，这个结构和二级引导器所使用的一样 //全局变量定义变量放在data段 #define HAL_DEFGLOB_VARIABLE(vartype,varname) \\ EXTERN __attribute__((section(\".data\"))) vartype varname HAL_DEFGLOB_VARIABLE(machbstart_t,kmachbsp); init_bdvideo函数 void init_bdvideo() &#123; dftgraph_t *kghp = &amp;kdftgh; //初始化图形数据结构，里面放有图形模式，分辨率，图形驱动函数指针 init_dftgraph(); //初始bga图形显卡的函数指针 init_bga(); //初始vbe图形显卡的函数指针 init_vbe(); //清空屏幕 为黑色 fill_graph(kghp, BGRA(0, 0, 0)); //显示背景图片 set_charsdxwflush(0, 0); hal_background(); return; &#125; dftgraph_t结构体 typedef struct s_DFTGRAPH &#123; u64_t gh_mode; //图形模式 u64_t gh_x; //水平像素点 u64_t gh_y; //垂直像素点 u64_t gh_framphyadr; //显存物理地址 u64_t gh_fvrmphyadr; //显存虚拟地址 u64_t gh_fvrmsz; //显存大小 u64_t gh_onepixbits; //一个像素字占用的数据位数 u64_t gh_onepixbyte; u64_t gh_vbemodenr; //vbe模式号 u64_t gh_bank; //显存的bank数 u64_t gh_curdipbnk; //当前bank u64_t gh_nextbnk; //下一个bank u64_t gh_banksz; //bank大小 u64_t gh_fontadr; //字库地址 u64_t gh_fontsz; //字库大小 u64_t gh_fnthight; //字体高度 u64_t gh_nxtcharsx; //下一字符显示的x坐标 u64_t gh_nxtcharsy; //下一字符显示的y坐标 u64_t gh_linesz; //字符行高 pixl_t gh_deffontpx; //默认字体大小 u64_t gh_chardxw; u64_t gh_flush; u64_t gh_framnr; u64_t gh_fshdata; //刷新相关的 dftghops_t gh_opfun; //图形驱动操作函数指针结构体 &#125;dftgraph_t; typedef struct s_DFTGHOPS &#123; //读写显存数据 size_t (*dgo_read)(void* ghpdev,void* outp,size_t rdsz); size_t (*dgo_write)(void* ghpdev,void* inp,size_t wesz); sint_t (*dgo_ioctrl)(void* ghpdev,void* outp,uint_t iocode); //刷新 void (*dgo_flush)(void* ghpdev); sint_t (*dgo_set_bank)(void* ghpdev, sint_t bnr); //读写像素 pixl_t (*dgo_readpix)(void* ghpdev,uint_t x,uint_t y); void (*dgo_writepix)(void* ghpdev,pixl_t pix,uint_t x,uint_t y); //直接读写像素 pixl_t (*dgo_dxreadpix)(void* ghpdev,uint_t x,uint_t y); void (*dgo_dxwritepix)(void* ghpdev,pixl_t pix,uint_t x,uint_t y); //设置x，y坐标和偏移 sint_t (*dgo_set_xy)(void* ghpdev,uint_t x,uint_t y); sint_t (*dgo_set_vwh)(void* ghpdev,uint_t vwt,uint_t vhi); sint_t (*dgo_set_xyoffset)(void* ghpdev,uint_t xoff,uint_t yoff); //获取x，y坐标和偏移 sint_t (*dgo_get_xy)(void* ghpdev,uint_t* rx,uint_t* ry); sint_t (*dgo_get_vwh)(void* ghpdev,uint_t* rvwt,uint_t* rvhi); sint_t (*dgo_get_xyoffset)(void* ghpdev,uint_t* rxoff,uint_t* ryoff); &#125;dftghops_t; //刷新显存 void flush_videoram(dftgraph_t *kghp) &#123; kghp->gh_opfun.dgo_flush(kghp); return; &#125; 最后调用函数 //在halinit.c文件中 void init_hal() &#123; init_halplaltform(); return; &#125; //在hal_start.c文件中 void hal_start() &#123; init_hal();//初始化hal层，其中会调用初始化平台函数，在那里会调用初始化图形驱动 for(;;); return; &#125; 初始化内存相比较二级引导器的内存布局信息，内存管理器需要保存更多的信息，最好是顺序的内存布局信息，这样可以增加额外的功能属性，同时降低代码的复杂度。 定义结构s_PHYMMARGE #define PMR_T_OSAPUSERRAM 1 #define PMR_T_RESERVRAM 2 #define PMR_T_HWUSERRAM 8 #define PMR_T_ARACONRAM 0xf #define PMR_T_BUGRAM 0xff #define PMR_F_X86_32 (1&lt;&lt;0) #define PMR_F_X86_64 (1&lt;&lt;1) #define PMR_F_ARM_32 (1&lt;&lt;2) #define PMR_F_ARM_64 (1&lt;&lt;3) #define PMR_F_HAL_MASK 0xff typedef struct s_PHYMMARGE &#123; spinlock_t pmr_lock;//保护这个结构是自旋锁 u32_t pmr_type; //内存地址空间类型 u32_t pmr_stype; u32_t pmr_dtype; //内存地址空间的子类型，见上面的宏 u32_t pmr_flgs; //结构的标志与状态 u32_t pmr_stus; u64_t pmr_saddr; //内存空间的开始地址 u64_t pmr_lsize; //内存空间的大小 u64_t pmr_end; //内存空间的结束地址 u64_t pmr_rrvmsaddr;//内存保留空间的开始地址 u64_t pmr_rrvmend; //内存保留空间的结束地址 void* pmr_prip; //结构的私有数据指针，以后扩展所用 void* pmr_extp; //结构的扩展数据指针，以后扩展所用 &#125;phymmarge_t; 有些情况下内核要另起炉灶，不想把所有的内存空间都交给内存管理器去管理，所以要保留一部分内存空间，这就是上面结构中那两个 pmr_rrvmsaddr、pmr_rrvmend 字段的作用。 有了数据结构，我们还要写代码来操作它： u64_t initpmrge_core(e820map_t *e8sp, u64_t e8nr, phymmarge_t *pmargesp) &#123; u64_t retnr = 0; for (u64_t i = 0; i &lt; e8nr; i++) &#123; //根据一个e820map_t结构建立一个phymmarge_t结构 if (init_one_pmrge(&amp;e8sp[i], &amp;pmargesp[i]) == FALSE) &#123; return retnr; &#125; retnr++; &#125; return retnr; &#125; void init_phymmarge() &#123; machbstart_t *mbsp = &amp;kmachbsp; phymmarge_t *pmarge_adr = NULL; u64_t pmrgesz = 0; //根据machbstart_t机器信息结构计算获得phymmarge_t结构的开始地址和大小 ret_phymmarge_adrandsz(mbsp, &amp;pmarge_adr, &amp;pmrgesz); u64_t tmppmrphyadr = mbsp->mb_nextwtpadr; e820map_t *e8p = (e820map_t *)((adr_t)(mbsp->mb_e820padr)); //建立phymmarge_t结构 u64_t ipmgnr = initpmrge_core(e8p, mbsp->mb_e820nr, pmarge_adr); //把phymmarge_t结构的地址大小个数保存machbstart_t机器信息结构中 mbsp->mb_e820expadr = tmppmrphyadr; mbsp->mb_e820exnr = ipmgnr; mbsp->mb_e820exsz = ipmgnr * sizeof(phymmarge_t); mbsp->mb_nextwtpadr = PAGE_ALIGN(mbsp->mb_e820expadr + mbsp->mb_e820exsz); //phymmarge_t结构中地址空间从低到高进行排序，我已经帮你写好了 phymmarge_sort(pmarge_adr, ipmgnr); return; &#125; 根据 e820map_t 结构数组，建立了一个 phymmarge_t 结构数组，init_one_pmrge 函数正是把 e820map_t 结构中的信息复制到 phymmarge_t 结构中来。 调用 void init_halmm() &#123; init_phymmarge(); //init_memmgr(); return; &#125; 初始化中断在 x86 CPU 上，最多支持 256 个中断，还记得前面所说的中断表和中断门描述符吗，这意味着我们要准备 256 个中断门描述符和 256 个中断处理程序的入口。 typedef struct s_GATE &#123; u16_t offset_low; /* 偏移 */ u16_t selector; /* 段选择子 */ u8_t dcount; /* 该字段只在调用门描述符中有效。如果在利用调用门调用子程序时引起特权级的转换和堆栈的改变，需要将外层堆栈中的参数复制到内层堆栈。该双字计数字段就是用于说明这种情况发生时，要复制的双字参数的数量。*/ u8_t attr; /* P(1) DPL(2) DT(1) TYPE(4) */ u16_t offset_high; /* 偏移的高位段 */ u32_t offset_high_h; u32_t offset_resv; &#125;__attribute__((packed)) gate_t; //定义中断表 HAL_DEFGLOB_VARIABLE(gate_t,x64_idt)[IDTMAX]; 中断表其实是个 gate_t 结构的数组，由 CPU 的 IDTR 寄存器指向，IDTMAX 为 256 定义函数给中断表设置数据 //vector 向量也是中断号 //desc_type 中断门类型，中断门，陷阱门 //handler 中断处理程序的入口地址 //privilege 中断门的权限级别 void set_idt_desc(u8_t vector, u8_t desc_type, inthandler_t handler, u8_t privilege) &#123; gate_t *p_gate = &amp;x64_idt[vector]; u64_t base = (u64_t)handler; p_gate->offset_low = base &amp; 0xFFFF; p_gate->selector = SELECTOR_KERNEL_CS; p_gate->dcount = 0; p_gate->attr = (u8_t)(desc_type | (privilege &lt;&lt; 5)); p_gate->offset_high = (u16_t)((base >> 16) &amp; 0xFFFF); p_gate->offset_high_h = (u32_t)((base >> 32) &amp; 0xffffffff); p_gate->offset_resv = 0; return; &#125; 上面的代码，正是按照要求，把这些数据填入中断门描述符中的。有了中断门之后，还差中断处理程序，中断处理程序只负责这三件事： 保护 CPU 寄存器，即中断发生时的程序运行的上下文。 调用中断处理程序，这个程序可以是修复异常的，可以是设备驱动程序中对设备响应的程序。 恢复 CPU 寄存器，即恢复中断时程序运行的上下文，使程序继续运行。 先来写好完成以上三个功能的汇编宏代码，避免写 256 遍同样的代码，代码如下 &#x2F;&#x2F;保存中断后的寄存器 %macro SAVEALL 0 push rax push rbx push rcx push rdx push rbp push rsi push rdi push r8 push r9 push r10 push r11 push r12 push r13 push r14 push r15 xor r14,r14 mov r14w,ds push r14 mov r14w,es push r14 mov r14w,fs push r14 mov r14w,gs push r14 %endmacro &#x2F;&#x2F;恢复中断后寄存器 %macro RESTOREALL 0 pop r14 mov gs,r14w pop r14 mov fs,r14w pop r14 mov es,r14w pop r14 mov ds,r14w pop r15 pop r14 pop r13 pop r12 pop r11 pop r10 pop r9 pop r8 pop rdi pop rsi pop rbp pop rdx pop rcx pop rbx pop rax iretq %endmacro &#x2F;&#x2F;保存异常下的寄存器 %macro SAVEALLFAULT 0 push rax push rbx push rcx push rdx push rbp push rsi push rdi push r8 push r9 push r10 push r11 push r12 push r13 push r14 push r15 xor r14,r14 mov r14w,ds push r14 mov r14w,es push r14 mov r14w,fs push r14 mov r14w,gs push r14 %endmacro &#x2F;&#x2F;恢复异常下寄存器 %macro RESTOREALLFAULT 0 pop r14 mov gs,r14w pop r14 mov fs,r14w pop r14 mov es,r14w pop r14 mov ds,r14w pop r15 pop r14 pop r13 pop r12 pop r11 pop r10 pop r9 pop r8 pop rdi pop rsi pop rbp pop rdx pop rcx pop rbx pop rax add rsp,8 iretq %endmacro &#x2F;&#x2F;没有错误码CPU异常 %macro SRFTFAULT 1 push _NOERRO_CODE SAVEALLFAULT mov r14w,0x10 mov ds,r14w mov es,r14w mov fs,r14w mov gs,r14w mov rdi,%1 ;rdi, rsi mov rsi,rsp call hal_fault_allocator RESTOREALLFAULT %endmacro &#x2F;&#x2F;CPU异常 %macro SRFTFAULT_ECODE 1 SAVEALLFAULT mov r14w,0x10 mov ds,r14w mov es,r14w mov fs,r14w mov gs,r14w mov rdi,%1 mov rsi,rsp call hal_fault_allocator RESTOREALLFAULT %endmacro &#x2F;&#x2F;硬件中断 %macro HARWINT 1 SAVEALL mov r14w,0x10 mov ds,r14w mov es,r14w mov fs,r14w mov gs,r14w mov rdi, %1 mov rsi,rsp call hal_intpt_allocator RESTOREALL %endmacro 有的 CPU 异常，CPU 自动把异常码压入到栈中，而有的 CPU 异常没有异常码，为了统一，我们对没有异常码的手动压入一个常数，维持栈的平衡。 有了中断异常处理的宏，我们还要它们变成中断异常的处理程序入口点函数。汇编函数其实就是一个标号加一段汇编代码，C 编译器把 C 语言函数编译成汇编代码后，也是标号加汇编代码，函数名就是标号 //除法错误异常 比如除0 exc_divide_error: SRFTFAULT 0 //单步执行异常 exc_single_step_exception: SRFTFAULT 1 exc_nmi: SRFTFAULT 2 //调试断点异常 exc_breakpoint_exception: SRFTFAULT 3 //溢出异常 exc_overflow: SRFTFAULT 4 //段不存在异常 exc_segment_not_present: SRFTFAULT_ECODE 11 //栈异常 exc_stack_exception: SRFTFAULT_ECODE 12 //通用异常 exc_general_protection: SRFTFAULT_ECODE 13 //缺页异常 exc_page_fault: SRFTFAULT_ECODE 14 hxi_exc_general_intpfault: SRFTFAULT 256 //硬件1～7号中断 hxi_hwint00: HARWINT (INT_VECTOR_IRQ0+0) hxi_hwint01: HARWINT (INT_VECTOR_IRQ0+1) hxi_hwint02: HARWINT (INT_VECTOR_IRQ0+2) hxi_hwint03: HARWINT (INT_VECTOR_IRQ0+3) hxi_hwint04: HARWINT (INT_VECTOR_IRQ0+4) hxi_hwint05: HARWINT (INT_VECTOR_IRQ0+5) hxi_hwint06: HARWINT (INT_VECTOR_IRQ0+6) hxi_hwint07: HARWINT (INT_VECTOR_IRQ0+7) 有了中断程序入口地址，就可以设置中断门描述符 void init_idt_descriptor() &#123; //一开始把所有中断的处理程序设置为保留的通用处理程序 for (u16_t intindx = 0; intindx &lt;= 255; intindx++) &#123; set_idt_desc((u8_t)intindx, DA_386IGate, hxi_exc_general_intpfault, PRIVILEGE_KRNL); &#125; set_idt_desc(INT_VECTOR_DIVIDE, DA_386IGate, exc_divide_error, PRIVILEGE_KRNL); set_idt_desc(INT_VECTOR_DEBUG, DA_386IGate, exc_single_step_exception, PRIVILEGE_KRNL); set_idt_desc(INT_VECTOR_NMI, DA_386IGate, exc_nmi, PRIVILEGE_KRNL); set_idt_desc(INT_VECTOR_BREAKPOINT, DA_386IGate, exc_breakpoint_exception, PRIVILEGE_USER); set_idt_desc(INT_VECTOR_OVERFLOW, DA_386IGate, exc_overflow, PRIVILEGE_USER); //篇幅所限，未全部展示 set_idt_desc(INT_VECTOR_PAGE_FAULT, DA_386IGate, exc_page_fault, PRIVILEGE_KRNL); set_idt_desc(INT_VECTOR_IRQ0 + 0, DA_386IGate, hxi_hwint00, PRIVILEGE_KRNL); set_idt_desc(INT_VECTOR_IRQ0 + 1, DA_386IGate, hxi_hwint01, PRIVILEGE_KRNL); set_idt_desc(INT_VECTOR_IRQ0 + 2, DA_386IGate, hxi_hwint02, PRIVILEGE_KRNL); set_idt_desc(INT_VECTOR_IRQ0 + 3, DA_386IGate, hxi_hwint03, PRIVILEGE_KRNL); //篇幅所限，未全部展示 return; &#125; 调用 void init_halintupt() &#123; init_idt_descriptor(); init_intfltdsc(); return; &#125; 但是，前面我们只是解决了中断的 CPU 相关部分，而 CPU 只是响应中断，但是并不能解决产生中断的问题。比如缺页中断来了，我们要解决内存地址映射关系，程序才可以继续运行。再比如硬盘中断来了，我们要读取硬盘的数据，要处理这问题，就要写好相应的处理函数。 中断异常描述符 typedef struct s_INTFLTDSC&#123; spinlock_t i_lock; u32_t i_flg; u32_t i_stus; uint_t i_prity; //中断优先级 uint_t i_irqnr; //中断号 uint_t i_deep; //中断嵌套深度 u64_t i_indx; //中断计数 list_h_t i_serlist; //也可以使用中断回调函数的方式 uint_t i_sernr; //中断回调函数个数 list_h_t i_serthrdlst; //中断线程链表头 uint_t i_serthrdnr; //中断线程个数 void* i_onethread; //只有一个中断线程时直接用指针 void* i_rbtreeroot; //如果中断线程太多则按优先级组成红黑树 list_h_t i_serfisrlst; uint_t i_serfisrnr; void* i_msgmpool; //可能的中断消息池 void* i_privp; void* i_extp; &#125;intfltdsc_t; 如果内核或者设备驱动程序要安装一个中断处理函数，就要先申请一个 intserdsc_t 结构体，然后把中断函数的地址写入其中，最后把这个结构挂载到对应的 intfltdsc_t 结构中的 i_serfisrlst 链表中。 为什么不能直接把中断处理函数放在 intfltdsc_t 结构中呢，还要多此一举搞个 intserdsc_t 结构体呢？ 因为我们的计算机中可能有很多设备，每个设备都可能产生中断，但是中断控制器的中断信号线是有限的。你可以这样理解：中断控制器最多只能产生几十号中断号，而设备不止几十个，所以会有多个设备共享一根中断信号线。这就导致一个中断发生后，无法确定是哪个设备产生的中断，所以我们干脆让设备驱动程序来决定，因为它是最了解设备的。这里我们让这个 intfltdsc_t 结构上的所有中断处理函数都依次执行，查看是不是自己的设备产生了中断，如果是就处理，不是则略过。 //定义intfltdsc_t结构数组大小为256 HAL_DEFGLOB_VARIABLE(intfltdsc_t,machintflt)[IDTMAX]; 实现中断异常分发函数 //中断处理函数 void hal_do_hwint(uint_t intnumb, void *krnlsframp) &#123; intfltdsc_t *ifdscp = NULL; cpuflg_t cpuflg; //根据中断号获取中断异常描述符地址 ifdscp = hal_retn_intfltdsc(intnumb); //对断异常描述符加锁并中断 hal_spinlock_saveflg_cli(&amp;ifdscp->i_lock, &amp;cpuflg); ifdscp->i_indx++; ifdscp->i_deep++; //运行中断处理的回调函数 hal_run_intflthandle(intnumb, krnlsframp); ifdscp->i_deep--; //解锁并恢复中断状态 hal_spinunlock_restflg_sti(&amp;ifdscp->i_lock, &amp;cpuflg); return; &#125; //异常分发器 void hal_fault_allocator(uint_t faultnumb, void *krnlsframp) &#123; //我们的异常处理回调函数也是放在中断异常描述符中的 hal_do_hwint(faultnumb, krnlsframp); return; &#125; //中断分发器 void hal_hwint_allocator(uint_t intnumb, void *krnlsframp) &#123; hal_do_hwint(intnumb, krnlsframp); return; &#125; hal_run_intflthandle负责调用中断处理函数 void hal_run_intflthandle(uint_t ifdnr, void *sframe) &#123; intserdsc_t *isdscp; list_h_t *lst; //根据中断号获取中断异常描述符地址 intfltdsc_t *ifdscp = hal_retn_intfltdsc(ifdnr); //遍历i_serlist链表 list_for_each(lst, &amp;ifdscp->i_serlist) &#123; //获取i_serlist链表上对象即intserdsc_t结构 isdscp = list_entry(lst, intserdsc_t, s_list); //调用中断处理回调函数 isdscp->s_handle(ifdnr, isdscp->s_device, sframe); &#125; return; &#125; 初始化中断控制器把 CPU 端的中断搞定了以后，还有设备端的中断，这个可以交给设备驱动程序，但是 CPU 和设备之间的中断控制器，还需要我们出面解决。 多个设备的中断信号线都会连接到中断控制器上，中断控制器可以决定启用或者屏蔽哪些设备的中断，还可以决定设备中断之间的优先线，所以它才叫中断控制器 x86 平台上的中断控制器有多种，最开始是 8259A，然后是 IOAPIC，最新的是 MSI-X。为了简单的说明原理，我们选择了 8259A 中断控制器。 8259A 在任何 x86 平台上都可以使用，x86 平台使用了两片 8259A 芯片，以级联的方式存在。它拥有 15 个中断源（即可以有 15 个中断信号接入）。 上面直接和 CPU 连接的是主 8259A，下面的是从 8259A，每一个 8259A 芯片都有两个 I/O 端口，我们可以通过它们对 8259A 进行编程。 主 8259A 的端口地址是 0x20，0x21；从 8259A 的端口地址是 0xA0，0xA1 下面我们来做代码初始化，我们程序员可以向 8259A 写两种命令字： ICW 和 OCW；ICW 这种命令字用来实现 8259a 芯片的初始化。而 OCW 这种命令用来向 8259A 发布命令，以对其进行控制。OCW 可以在 8259A 被初始化之后的任何时候被使用 8259.c void init_i8259() &#123; //初始化主从8259a out_u8_p(ZIOPT, ICW1); out_u8_p(SIOPT, ICW1); out_u8_p(ZIOPT1, ZICW2); out_u8_p(SIOPT1, SICW2); out_u8_p(ZIOPT1, ZICW3); out_u8_p(SIOPT1, SICW3); out_u8_p(ZIOPT1, ICW4); out_u8_p(SIOPT1, ICW4); //屏蔽全部中断源 out_u8_p(ZIOPT1, 0xff); out_u8_p(SIOPT1, 0xff); return; &#125; 进入内核层由于内核层是从 hal 层进入的，必须在 hal_start() 函数中被调用，所以在此完成这个函数——init_krl() void init_krl() &#123; //禁止函数返回 die(0); return; &#125; 调用 void hal_start() &#123; //初始化hal层 init_hal(); //初始化内核层 init_krl(); return; &#125; 小结 一、HAL层调用链hal_start() A、先去处理HAL层的初始化-&gt;init_hal() -&gt;-&gt;init_halplaltform()初始化平台-&gt;-&gt;-&gt;init_machbstart()主要是把二级引导器建立的机器信息结构，复制到了hal层一份给内核使用，同时也为释放二级引导器占用内存做好准备。其做法就是拷贝了一份mbsp到kmbsp，其中用到了虚拟地址转换hyadr_to_viradr-&gt;-&gt;-&gt;init_bdvideo()初始化图形机构初始化BGA显卡 或 VBE图形显卡信息【函数指针的使用】清空屏幕找到”background.bmp”，并显示背景图片-&gt;-&gt;-&gt;-&gt;hal_dspversion（）输出版本号等信息【vsprintfk】其中，用ret_charsinfo根据字体文件获取字符像素信息 -&gt;-&gt;move_img2maxpadr()将移动initldrsve.bin到最大地址 -&gt;-&gt;init_halmm()初始化内存-&gt;-&gt;-&gt;init_phymmarge申请phymmarge_t内存根据 e820map_t 结构数组，复制数据到phymmarge_t 结构数组按内存开始地址进行排序 -&gt;-&gt;init_halintupt();初始化中断-&gt;-&gt;-&gt;init_descriptor();初始化GDT描述符x64_gdt-&gt;-&gt;-&gt;init_idt_descriptor();初始化IDT描述符x64_idt，绑定了中断编号及中断处理函数-&gt;-&gt;-&gt;init_intfltdsc();初始化中断异常表machintflt，拷贝了中断相关信息-&gt;-&gt;-&gt;init_i8259();初始化8529芯片中断-&gt;-&gt;-&gt;i8259_enabled_line(0);好像是取消mask，开启中断请求 最后，跳转去处理内核初始化-&gt;init_krl() 二、中断调用链，以硬件中断为例A、kernel.inc中，通过宏定义，进行了中断定义。以硬件中断为例，可以在kernel.inc中看到：宏为HARWINT，硬件中断分发器函数为hal_hwint_allocator%macro HARWINT 1 保存现场…… mov rdi, %1 mov rsi,rsp call hal_hwint_allocator 恢复现场……%endmacro B、而在kernel.asm中，定义了各种硬件中断编号，比如hxi_hwint00，作为中断处理入口ALIGN 16hxi_hwint00: HARWINT (INT_VECTOR_IRQ0+0) C、有硬件中断时，会先到达中断处理入口，然后调用到硬件中断分发器函数hal_hwint_allocator第一个参数为中断编号，在rdi第二个参数为中断发生时的栈指针，在rsi然后调用异常处理函数hal_do_hwint D、hal_do_hwint加锁调用中断回调函数hal_run_intflthandle释放锁 E、hal_run_intflthandle先获取中断异常表machintflt然后调用i_serlist 链表上所有挂载intserdsc_t 结构中的中断处理的回调函数，是否处理由函数自己判断 F、中断处理完毕 G、异常处理类似，只是触发源头不太一样而已","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://blog.innnovation.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://blog.innnovation.cn/tags/OS/"}]},{"title":"操作系统-硬件到软件启动初始化-设置工作模式与环境","slug":"操作系统-设置工作模式与环境","date":"2021-06-24T16:00:00.000Z","updated":"2021-07-05T06:15:14.845Z","comments":true,"path":"2021/06/25/cao-zuo-xi-tong-she-zhi-gong-zuo-mo-shi-yu-huan-jing/","link":"","permalink":"https://blog.innnovation.cn/2021/06/25/cao-zuo-xi-tong-she-zhi-gong-zuo-mo-shi-yu-huan-jing/","excerpt":"","text":"部分代码来源于极客时间《操作系统45讲》，这里记录了我自己操作的过程和思路 建立计算机（磁盘）一个常规操作系统的启动如下图： 而这里的helloOS中的文件我们称之为内核镜像文件，我们可以引导GRUB加载一个或者多个文件 多文件加载时grub会解析如下图的文件然后加载： 映像文件头描述符和文件描述符如下： //映像文件头描述符 typedef struct s_mlosrddsc &#123; u64_t mdc_mgic; //映像文件标识 u64_t mdc_sfsum;//未使用 u64_t mdc_sfsoff;//未使用 u64_t mdc_sfeoff;//未使用 u64_t mdc_sfrlsz;//未使用 u64_t mdc_ldrbk_s;//映像文件中二级引导器的开始偏移 u64_t mdc_ldrbk_e;//映像文件中二级引导器的结束偏移 u64_t mdc_ldrbk_rsz;//映像文件中二级引导器的实际大小 u64_t mdc_ldrbk_sum;//映像文件中二级引导器的校验和 u64_t mdc_fhdbk_s;//映像文件中文件头描述的开始偏移 u64_t mdc_fhdbk_e;//映像文件中文件头描述的结束偏移 u64_t mdc_fhdbk_rsz;//映像文件中文件头描述的实际大小 u64_t mdc_fhdbk_sum;//映像文件中文件头描述的校验和 u64_t mdc_filbk_s;//映像文件中文件数据的开始偏移 u64_t mdc_filbk_e;//映像文件中文件数据的结束偏移 u64_t mdc_filbk_rsz;//映像文件中文件数据的实际大小 u64_t mdc_filbk_sum;//映像文件中文件数据的校验和 u64_t mdc_ldrcodenr;//映像文件中二级引导器的文件头描述符的索引号 u64_t mdc_fhdnr;//映像文件中文件头描述符有多少个 u64_t mdc_filnr;//映像文件中文件头有多少个 u64_t mdc_endgic;//映像文件结束标识 u64_t mdc_rv;//映像文件版本 &#125;mlosrddsc_t; #define FHDSC_NMAX 192 //文件名长度 //文件头描述符 typedef struct s_fhdsc &#123; u64_t fhd_type;//文件类型 u64_t fhd_subtype;//文件子类型 u64_t fhd_stuts;//文件状态 u64_t fhd_id;//文件id u64_t fhd_intsfsoff;//文件在映像文件位置开始偏移 u64_t fhd_intsfend;//文件在映像文件的结束偏移 u64_t fhd_frealsz;//文件实际大小 u64_t fhd_fsum;//文件校验和 char fhd_name[FHDSC_NMAX];//文件名 &#125;fhdsc_t; 我用的是windows10+VMware的方式进行开发： 我在VMware中先建立了虚拟机： 1GB 1CPU 100MB硬盘 其他64位 在Ubuntu64bit下生产硬盘 在虚拟机中开辟一块全0的100MB的虚拟磁盘 dd bs=512 if=/dev/zero of=hd.img count=204800 ;bs:表示块大小，这里是512字节 ;if：表示输入文件，/dev/zero就是Linux下专门返回0数据的设备文件，读取它就返回0 ;of：表示输出文件，即我们的硬盘文件。 ;count：表示输出多少块 然后将这个文件转换为可识别的虚拟磁盘： 将文件转为设备并设置回环设备 格式化为EXT4文件系统 挂在虚拟磁盘到目录下 安装GRUB sudo losetup -a #查看所有设备，我的机器上已经有十几个设备了，不能使用这些设备的名称 sudo losetup /dev/loop15 hd.img #0-14都被占用了 sudo mkfs.ext4 -q /dev/loop15 sudo mount -o loop ./hd.img ./hdisk/ ;挂载硬盘文件 sudo mkdir ./hdisk/boot/ ;建立boot目录 第一步挂载虚拟硬盘文件为loop0回环设备 sudo losetup /dev/loop15 hd.img sudo mount -o loop ./hd.img ./hdisk/ ;挂载硬盘文件 第二步安装GRUB sudo grub-install --boot-directory=./hdisk/boot/ --force --allow-floppy /dev/loop15 ；--boot-directory 指向先前我们在虚拟硬盘中建立的boot目录。 ；--force --allow-floppy ：指向我们的虚拟硬盘设备文件/dev/loop0 安装完毕后用sudo在**/hdisk/boot/grub/** 目录下建立一个grub.cfg 文本文件,grub会通过该文件找到系统镜像 grub.cfg menuentry 'HelloOS' &#123; #名字随意 insmod part_msdos insmod ext2 set root='hd0' #我的机器只能指定hd0，表示第一块磁盘引导启动 multiboot2 /boot/HelloOS.eki #加载boot目录下的HelloOS.eki文件 boot #引导启动 &#125; set timeout_style=menu if [ \"$&#123;timeout&#125;\" = 0 ]; then set timeout=10 #等待10秒钟自动启动 fi 硬盘设置好后如图，hdisk文件夹中就是hd.img磁盘镜像中的内容，修改hdisk即可修改磁盘 然后将hd.img复制到物理机，通过StarWindConverter软件转换img磁盘格式为vmdk格式（让VMware可以加载） 建造二级引导器课程开源代码https://gitee.com/lmos/cosmos 先设计一个数据结构存放机器信息 typedef struct s_MACHBSTART &#123; u64_t mb_krlinitstack;//内核栈地址 u64_t mb_krlitstacksz;//内核栈大小 u64_t mb_imgpadr;//操作系统映像 u64_t mb_imgsz;//操作系统映像大小 u64_t mb_bfontpadr;//操作系统字体地址 u64_t mb_bfontsz;//操作系统字体大小 u64_t mb_fvrmphyadr;//机器显存地址 u64_t mb_fvrmsz;//机器显存大小 u64_t mb_cpumode;//机器CPU工作模式 u64_t mb_memsz;//机器内存大小 u64_t mb_e820padr;//机器e820数组地址 u64_t mb_e820nr;//机器e820数组元素个数 u64_t mb_e820sz;//机器e820数组大小 //…… u64_t mb_pml4padr;//机器页表数据地址 u64_t mb_subpageslen;//机器页表个数 u64_t mb_kpmapphymemsz;//操作系统映射空间大小 //…… graph_t mb_ghparm;//图形信息 &#125;__attribute__((packed)) machbstart_t; 下图为课程插图 接着实现GRUB头 流程：初始化 CPU 的寄存器，加载 GDT，切换到 CPU 的保护模式 MBT_HDR_FLAGS EQU 0x00010003 MBT_HDR_MAGIC EQU 0x1BADB002 MBT2_MAGIC EQU 0xe85250d6 global _start extern inithead_entry [section .text] [bits 32] _start: jmp _entry align 4 mbt_hdr: dd MBT_HDR_MAGIC dd MBT_HDR_FLAGS dd -(MBT_HDR_MAGIC+MBT_HDR_FLAGS) dd mbt_hdr dd _start dd 0 dd 0 dd _entry ALIGN 8 mbhdr: DD 0xE85250D6 DD 0 DD mhdrend - mbhdr DD -(0xE85250D6 + 0 + (mhdrend - mbhdr)) DW 2, 0 DD 24 DD mbhdr DD _start DD 0 DD 0 DW 3, 0 DD 12 DD _entry DD 0 DW 0, 0 DD 8 mhdrend: 关中断，加载GDT _entry: cli ；关中断 in al, 0x70 or al, 0x80 out 0x70,al ；关掉不可屏蔽中断 lgdt [GDT_PTR] ；加载GDT地址到GDTR寄存器 jmp dword 0x8 :_32bits_mode ；长跳转刷新CS影子寄存器 ;……………… ;GDT全局段描述符表 GDT_START: knull_dsc: dq 0 kcode_dsc: dq 0x00cf9e000000ffff kdata_dsc: dq 0x00cf92000000ffff k16cd_dsc: dq 0x00009e000000ffff ；16位代码段描述符 k16da_dsc: dq 0x000092000000ffff ；16位数据段描述符 GDT_END: GDT_PTR: GDTLEN dw GDT_END-GDT_START-1 ;GDT界限 GDTBASE dd GDT_ST 初始化段寄存器和通用寄存器、栈寄存器，为C函数做准备 _32bits_mode： mov ax, 0x10 mov ds, ax mov ss, ax mov es, ax mov fs, ax mov gs, ax xor eax,eax xor ebx,ebx xor ecx,ecx xor edx,edx xor edi,edi xor esi,esi xor ebp,ebp xor esp,esp mov esp,0x7c00 ；设置栈顶为0x7c00 call inithead_entry ；调用inithead_entry函数在inithead.c中实现 jmp 0x200000 ；跳转到0x200000地址 于是实现inithead_entry函数 函数中调用write_realintsvefile write_ldrkrlfile主要作用就是把映像文件中的 initldrsve.bin 文件和 initldrkrl.bin 文件写入到特定的内存地址空间中加载地址在宏中定义 而加载时又依赖find_file 和 m2mcopy函数 find_file 函数负责扫描映像文件中的文件头描述符，对比其中的文件名，然后返回对应的文件头描述符的地址，这样就可以得到文件在映像文件中的位置和大小了。 m2mcopy就是复制镜像到内存空间操作。 #define MDC_ENDGIC 0xaaffaaffaaffaaff #define MDC_RVGIC 0xffaaffaaffaaffaa #define REALDRV_PHYADR 0x1000 #define IMGFILE_PHYADR 0x4000000 #define IMGKRNL_PHYADR 0x2000000 #define LDRFILEADR IMGFILE_PHYADR #define MLOSDSC_OFF (0x1000) #define MRDDSC_ADR (mlosrddsc_t*)(LDRFILEADR+0x1000) void inithead_entry() &#123; write_realintsvefile(); write_ldrkrlfile(); return; &#125; //写initldrsve.bin文件到特定的内存中 void write_realintsvefile() &#123; fhdsc_t *fhdscstart = find_file(\"initldrsve.bin\"); if (fhdscstart == NULL) &#123; error(\"not file initldrsve.bin\"); &#125; m2mcopy((void *)((u32_t)(fhdscstart->fhd_intsfsoff) + LDRFILEADR), (void *)REALDRV_PHYADR, (sint_t)fhdscstart->fhd_frealsz); return; &#125; //写initldrkrl.bin文件到特定的内存中 void write_ldrkrlfile() &#123; fhdsc_t *fhdscstart = find_file(\"initldrkrl.bin\"); if (fhdscstart == NULL) &#123; error(\"not file initldrkrl.bin\"); &#125; m2mcopy((void *)((u32_t)(fhdscstart->fhd_intsfsoff) + LDRFILEADR), (void *)ILDRKRL_PHYADR, (sint_t)fhdscstart->fhd_frealsz); return; &#125; //在映像文件中查找对应的文件 fhdsc_t *find_file(char_t *fname) &#123; mlosrddsc_t *mrddadrs = MRDDSC_ADR; if (mrddadrs->mdc_endgic != MDC_ENDGIC || mrddadrs->mdc_rv != MDC_RVGIC || mrddadrs->mdc_fhdnr &lt; 2 || mrddadrs->mdc_filnr &lt; 2) &#123; error(\"no mrddsc\"); &#125; s64_t rethn = -1; fhdsc_t *fhdscstart = (fhdsc_t *)((u32_t)(mrddadrs->mdc_fhdbk_s) + LDRFILEADR); for (u64_t i = 0; i &lt; mrddadrs->mdc_fhdnr; i++) &#123; if (strcmpl(fname, fhdscstart[i].fhd_name) == 0) &#123; rethn = (s64_t)i; goto ok_l; &#125; &#125; rethn = -1; ok_l: if (rethn &lt; 0) &#123; error(\"not find file\"); &#125; return &amp;fhdscstart[rethn]; &#125; 在前面的GRUB头部分最后一行代码jmp 0x200000 跳转地址正好是initldrkrl.bin内存中的地址，该模块即为二级引导器主模块 由于模块改变，还需要加载 GDTR 和 IDTR 寄存器，然后初始化 CPU 相关的寄存器 _entry: cli lgdt [GDT_PTR]；加载GDT地址到GDTR寄存器 lidt [IDT_PTR]；加载IDT地址到IDTR寄存器 jmp dword 0x8 :_32bits_mode；长跳转刷新CS影子寄存器 _32bits_mode: mov ax, 0x10 ; 数据段选择子(目的) mov ds, ax mov ss, ax mov es, ax mov fs, ax mov gs, ax xor eax,eax xor ebx,ebx xor ecx,ecx xor edx,edx xor edi,edi xor esi,esi xor ebp,ebp xor esp,esp mov esp,0x90000 ；使得栈底指向了0x90000 call ldrkrl_entry ；调用ldrkrl_entry函数 xor ebx,ebx jmp 0x2000000 ；跳转到0x2000000的内存地址 jmp $ GDT_START: knull_dsc: dq 0 kcode_dsc: dq 0x00cf9a000000ffff ;a-e kdata_dsc: dq 0x00cf92000000ffff k16cd_dsc: dq 0x00009a000000ffff ；16位代码段描述符 k16da_dsc: dq 0x000092000000ffff ；16位数据段描述符 GDT_END: GDT_PTR: GDTLEN dw GDT_END-GDT_START-1 ;GDT界限 GDTBASE dd GDT_START IDT_PTR: IDTLEN dw 0x3ff IDTBAS dd 0 ；这是BIOS中断表的地址和长度 如何调用bios中断C语言运行在32位保护模式下，而中断在16位实模式下工作 于是需要实现一个切换运行模式的功能，流程如下： 保存 C 语言环境下的 CPU 上下文 ，即保护模式下的所有通用寄存器、段寄存器、程序指针寄存器，栈寄存器，把它们都保存在内存中。 切换回实模式，调用 BIOS 中断，把 BIOS 中断返回的相关结果，保存在内存中。 切换回保护模式，重新加载第 1 步中保存的寄存器。这样 C 语言代码才能重新恢复执行。 realadr_call_entry: pushad ;保存通用寄存器 push ds push es push fs ;保存4个段寄存器 push gs call save_eip_jmp ；调用save_eip_jmp pop gs pop fs pop es ;恢复4个段寄存器 pop ds popad ;恢复通用寄存器 ret save_eip_jmp: pop esi ；弹出call save_eip_jmp时保存的eip到esi寄存器中， mov [PM32_EIP_OFF],esi ；把eip保存到特定的内存空间中 mov [PM32_ESP_OFF],esp ；把esp保存到特定的内存空间中 jmp dword far [cpmty_mode]；长跳转这里表示把cpmty_mode处的第一个4字节装入eip，把其后的2字节装入cs cpmty_mode: dd 0x1000 dw 0x18 jmp $ jmp dword far [cpmty_mode]后面的0x18正是GDT 中的 16 位代码段描述符，偏址0x1000是要运行的代码 [bits 16] _start: _16_mode: mov bp,0x20 ;0x20是指向GDT中的16位数据段描述符 mov ds, bp mov es, bp mov ss, bp mov ebp, cr0 and ebp, 0xfffffffe mov cr0, ebp ；CR0.P&#x3D;0 关闭保护模式 jmp 0:real_entry ；刷新CS影子寄存器，真正进入实模式 real_entry: mov bp, cs mov ds, bp mov es, bp mov ss, bp ；重新设置实模式下的段寄存器 都是CS中值，即为0 mov sp, 08000h ；设置栈 mov bp,func_table add bp,ax call [bp] ；调用函数表中的汇编函数，ax是C函数中传递进来的 cli call disable_nmi mov ebp, cr0 or ebp, 1 mov cr0, ebp ；CR0.P&#x3D;1 开启保护模式 jmp dword 0x8 :_32bits_mode [BITS 32] _32bits_mode: mov bp, 0x10 mov ds, bp mov ss, bp；重新设置保护模式下的段寄存器0x10是32位数据段描述符的索引 mov esi,[PM32_EIP_OFF]；加载先前保存的EIP mov esp,[PM32_ESP_OFF]；加载先前保存的ESP jmp esi ；eip&#x3D;esi 回到了realadr_call_entry函数中 func_table: ;函数表 dw _getmmap ；获取内存布局视图的函数 dw _read ；读取硬盘的函数 dw _getvbemode ；获取显卡VBE模式 dw _getvbeonemodeinfo ；获取显卡VBE模式的数据 dw _setvbemode ；设置显卡VBE模式 进入二级引导器主函数 void ldrkrl_entry() &#123; init_bstartparm();//收集机器环境信息的主函数 return; &#125; 小结1、grub启动后，选择对应的启动菜单项，grub会通过自带文件系统驱动，定位到对应的eki文件 2、grub会尝试加载eki文件【eki文件需要满足grub多协议引导头的格式要求】 这些是在imginithead.asm中实现的，所以要包括： A、grub文件头，包括魔数、grub1和grub2支持等 B、定位的_start符号等 3、grub校验成功后，会调用_start，然跳转到_entry A、_entry中:关闭中断 B、加载GDT C、然后进入_32bits_mode，清理寄存器，设置栈顶 D、调用inithead_entry【C】 4、inithead_entry.c A、从imginithead.asm进入后，首先进入函数调用inithead_entry B、初始化光标，清屏 C、从eki文件内部，找到initldrsve.bin文件，并分别拷贝到内存的指定物理地址 D、从eki文件内部，找到initldrkrl.bin文件，并分别拷贝到内存的指定物理地址 E、返回imginithead.asm 5、imginithead.asm中继续执行 jmp 0x200000 而这个位置，就是initldrkrl.bin在内存的位置ILDRKRL_PHYADR 所以后面要执行initldrkrl.bin的内容 6、这样就到了ldrkrl32.asm的_entry A、将GDT加载到GDTR寄存器【内存】 B、将IDT加载到IDTR寄存器【中断】 C、跳转到_32bits_mode 初始寄存器 初始化栈 调用ldrkrl_entry【C】 7、ldrkrlentry.c A、初始化光标，清屏 B、收集机器参数init_bstartparm【C】 8、bstartparm.c A、初始化machbstart_t B、各类初始化函数，填充machbstart_t的内容 C、返回 9、ldrkrlentry.c A、返回 10、ldrkrl32.asm A、跳转到0x2000000地址继续执行 探查和搜集信息在引导器主函数中，需要检查 CPU 是否支持 64 位的工作模式、收集内存布局信息，看看是不是合乎我们操作系统的最低运行要求，还要设置操作系统需要的 MMU 页表、设置显卡模式、释放中文字体文件 void ldrkrl_entry() &#123; init_bstartparm();//收集机器环境信息的主函数 return; &#125; //========================================================= //初始化machbstart_t结构体，清0,并设置一个标志 void machbstart_t_init(machbstart_t* initp) &#123; memset(initp,0,sizeof(machbstart_t)); initp->mb_migc=MBS_MIGC; return; &#125; void init_bstartparm() &#123; machbstart_t* mbsp = MBSPADR;//1MB的内存地址 machbstart_t_init(mbsp); return; &#125; 上述代码中的结构体为1MB包含机器基本信息的结构体 检查cpuchk_cpuid、chk_cpu_longmode 来干两件事，一个是检查 CPU 否支持 CPUID 指令，然后另一个用 CPUID 指令检查 CPU 支持 64 位长模式 //通过改写Eflags寄存器的第21位，观察其位的变化判断是否支持CPUID int chk_cpuid() &#123; int rets = 0; __asm__ __volatile__( \"pushfl \\n\\t\" \"popl %%eax \\n\\t\" \"movl %%eax,%%ebx \\n\\t\" \"xorl $0x0200000,%%eax \\n\\t\" \"pushl %%eax \\n\\t\" \"popfl \\n\\t\" \"pushfl \\n\\t\" \"popl %%eax \\n\\t\" \"xorl %%ebx,%%eax \\n\\t\" \"jz 1f \\n\\t\" \"movl $1,%0 \\n\\t\" \"jmp 2f \\n\\t\" \"1: movl $0,%0 \\n\\t\" \"2: \\n\\t\" : \"=c\"(rets) : :); return rets; &#125; //检查CPU是否支持长模式 int chk_cpu_longmode() &#123; int rets = 0; __asm__ __volatile__( \"movl $0x80000000,%%eax \\n\\t\" \"cpuid \\n\\t\" //把eax中放入0x80000000调用CPUID指令 \"cmpl $0x80000001,%%eax \\n\\t\"//看eax中返回结果 \"setnb %%al \\n\\t\" //不为0x80000001,则不支持0x80000001号功能 \"jb 1f \\n\\t\" \"movl $0x80000001,%%eax \\n\\t\" \"cpuid \\n\\t\"//把eax中放入0x800000001调用CPUID指令，检查edx中的返回数据 \"bt $29,%%edx \\n\\t\" //长模式 支持位 是否为1 \"setcb %%al \\n\\t\" \"1: \\n\\t\" \"movzx %%al,%%eax \\n\\t\" : \"=a\"(rets) : :); return rets; &#125; //检查CPU主函数 void init_chkcpu(machbstart_t *mbsp) &#123; if (!chk_cpuid()) &#123; kerror(\"Your CPU is not support CPUID sys is die!\"); CLI_HALT(); &#125; if (!chk_cpu_longmode()) &#123; kerror(\"Your CPU is not support 64bits mode sys is die!\"); CLI_HALT(); &#125; mbsp->mb_cpumode = 0x40;//如果成功则设置机器信息结构的cpu模式为64位 return; &#125; 获取内存布局init_mem函数 #define ETYBAK_ADR 0x2000 #define PM32_EIP_OFF (ETYBAK_ADR) #define PM32_ESP_OFF (ETYBAK_ADR+4) #define E80MAP_NR (ETYBAK_ADR+64)//保存e820map_t结构数组元素个数的地址 #define E80MAP_ADRADR (ETYBAK_ADR+68) //保存e820map_t结构数组的开始地址 void init_mem(machbstart_t *mbsp) &#123; e820map_t *retemp; u32_t retemnr = 0; mmap(&amp;retemp, &amp;retemnr); if (retemnr == 0) &#123; kerror(\"no e820map\\n\"); &#125; //根据e820map_t结构数据检查内存大小 if (chk_memsize(retemp, retemnr, 0x100000, 0x8000000) == NULL) &#123; kerror(\"Your computer is low on memory, the memory cannot be less than 128MB!\"); &#125; mbsp->mb_e820padr = (u64_t)((u32_t)(retemp));//把e820map_t结构数组的首地址传给mbsp->mb_e820padr mbsp->mb_e820nr = (u64_t)retemnr;//把e820map_t结构数组元素个数传给mbsp->mb_e820nr mbsp->mb_e820sz = retemnr * (sizeof(e820map_t));//把e820map_t结构数组大小传给mbsp->mb_e820sz mbsp->mb_memsz = get_memsize(retemp, retemnr);//根据e820map_t结构数据计算内存大小。 return; &#125; void mmap(e820map_t **retemp, u32_t *retemnr) &#123; realadr_call_entry(RLINTNR(0), 0, 0); *retemnr = *((u32_t *)(E80MAP_NR)); *retemp = (e820map_t *)(*((u32_t *)(E80MAP_ADRADR))); return; &#125; 内存信息结构体 #define RAM_USABLE 1 //可用内存 #define RAM_RESERV 2 //保留内存不可使用 #define RAM_ACPIREC 3 //ACPI表相关的 #define RAM_ACPINVS 4 //ACPI NVS空间 #define RAM_AREACON 5 //包含坏内存 typedef struct s_e820&#123; u64_t saddr; /* 内存开始地址 */ u64_t lsize; /* 内存大小 */ u32_t type; /* 内存类型 */ &#125;e820map_t; mmap函数中调用了bios中断原因是，通过调中断获取e820map结构数组 其调用了实模式下的_getmmap函数来获取，代码如下 _getmmap: push ds push es push ss mov esi,0 mov dword[E80MAP_NR],esi mov dword[E80MAP_ADRADR],E80MAP_ADR ;e820map结构体开始地址 xor ebx,ebx mov edi,E80MAP_ADR loop: mov eax,0e820h ;获取e820map结构参数 mov ecx,20 ;e820map结构大小 mov edx,0534d4150h ;获取e820map结构参数必须是这个数据 int 15h ;BIOS的15h中断 jc .1 add edi,20 cmp edi,E80MAP_ADR+0x1000 jg .1 inc esi cmp ebx,0 jne loop ;循环获取e820map结构 jmp .2 .1: mov esi,0 ;出错处理，e820map结构数组元素个数为0 .2: mov dword[E80MAP_NR],esi ;e820map结构数组元素个数 pop ss pop es pop ds ret 初始化内核栈 #define IKSTACK_PHYADR (0x90000-0x10) #define IKSTACK_SIZE 0x1000 //初始化内核栈 void init_krlinitstack(machbstart_t *mbsp) &#123; if (1 > move_krlimg(mbsp, (u64_t)(0x8f000), 0x1001)) &#123; kerror(\"iks_moveimg err\"); &#125; mbsp->mb_krlinitstack = IKSTACK_PHYADR;//栈顶地址 mbsp->mb_krlitstacksz = IKSTACK_SIZE; //栈大小是4KB return; &#125; 内核空间为：0x8f000～（0x8f000+0x1001） 检查他们于其他空间是否有冲突即可 放置内核文件与字库文件 //放置内核文件 void init_krlfile(machbstart_t *mbsp) &#123; //在映像中查找相应的文件，并复制到对应的地址，并返回文件的大小，这里是查找kernel.bin文件 u64_t sz = r_file_to_padr(mbsp, IMGKRNL_PHYADR, \"kernel.bin\"); if (0 == sz) &#123; kerror(\"r_file_to_padr err\"); &#125; //放置完成后更新机器信息结构中的数据 mbsp->mb_krlimgpadr = IMGKRNL_PHYADR; mbsp->mb_krlsz = sz; //mbsp->mb_nextwtpadr始终要保持指向下一段空闲内存的首地址 mbsp->mb_nextwtpadr = P4K_ALIGN(mbsp->mb_krlimgpadr + mbsp->mb_krlsz); mbsp->mb_kalldendpadr = mbsp->mb_krlimgpadr + mbsp->mb_krlsz; return; &#125; //放置字库文件 void init_defutfont(machbstart_t *mbsp) &#123; u64_t sz = 0; //获取下一段空闲内存空间的首地址 u32_t dfadr = (u32_t)mbsp->mb_nextwtpadr; //在映像中查找相应的文件，并复制到对应的地址，并返回文件的大小，这里是查找font.fnt文件 sz = r_file_to_padr(mbsp, dfadr, \"font.fnt\"); if (0 == sz) &#123; kerror(\"r_file_to_padr err\"); &#125; //放置完成后更新机器信息结构中的数据 mbsp->mb_bfontpadr = (u64_t)(dfadr); mbsp->mb_bfontsz = sz; //更新机器信息结构中下一段空闲内存的首地址 mbsp->mb_nextwtpadr = P4K_ALIGN((u32_t)(dfadr) + sz); mbsp->mb_kalldendpadr = mbsp->mb_bfontpadr + mbsp->mb_bfontsz; return; &#125; 调用 r_file_to_padr 函数在映像中查找 kernel.bin 和 font.fnt 文件，并复制到对应的空闲内存空间中 建立 MMU 页表数据内核虚拟地址空间从 0xffff800000000000 开始，所以我们这个虚拟地址映射到从物理地址 0 开始，大小都是 0x400000000 即 16GB，也就是说我们要虚拟地址空间：0xffff800000000000～0xffff800400000000 映射到物理地址空间 0～0x400000000。 采用长模式下的 2MB 分页方式 #define KINITPAGE_PHYADR 0x1000000 void init_bstartpages(machbstart_t *mbsp) &#123; //顶级页目录 u64_t *p = (u64_t *)(KINITPAGE_PHYADR);//16MB地址处 //页目录指针 u64_t *pdpte = (u64_t *)(KINITPAGE_PHYADR + 0x1000); //页目录 u64_t *pde = (u64_t *)(KINITPAGE_PHYADR + 0x2000); //物理地址从0开始 u64_t adr = 0; if (1 > move_krlimg(mbsp, (u64_t)(KINITPAGE_PHYADR), (0x1000 * 16 + 0x2000))) &#123; kerror(\"move_krlimg err\"); &#125; //将顶级页目录、页目录指针的空间清0 for (uint_t mi = 0; mi &lt; PGENTY_SIZE; mi++) &#123; p[mi] = 0; pdpte[mi] = 0; &#125; //映射 for (uint_t pdei = 0; pdei &lt; 16; pdei++) &#123; pdpte[pdei] = (u64_t)((u32_t)pde | KPDPTE_RW | KPDPTE_P); for (uint_t pdeii = 0; pdeii &lt; PGENTY_SIZE; pdeii++) &#123;//大页KPDE_PS 2MB，可读写KPDE_RW，存在KPDE_P pde[pdeii] = 0 | adr | KPDE_PS | KPDE_RW | KPDE_P; adr += 0x200000; &#125; pde = (u64_t *)((u32_t)pde + 0x1000); &#125; //让顶级页目录中第0项和第((KRNL_VIRTUAL_ADDRESS_START) >> KPML4_SHIFT) &amp; 0x1ff项，指向同一个页目录指针页 p[((KRNL_VIRTUAL_ADDRESS_START) >> KPML4_SHIFT) &amp; 0x1ff] = (u64_t)((u32_t)pdpte | KPML4_RW | KPML4_P); p[0] = (u64_t)((u32_t)pdpte | KPML4_RW | KPML4_P); //把页表首地址保存在机器信息结构中 mbsp->mb_pml4padr = (u64_t)(KINITPAGE_PHYADR); mbsp->mb_subpageslen = (u64_t)(0x1000 * 16 + 0x2000); mbsp->mb_kpmapphymemsz = (u64_t)(0x400000000); return; &#125; 映射的核心逻辑由两重循环控制，外层循环控制页目录指针顶，只有 16 项，其中每一项都指向一个页目录，每个页目录中有 512 个物理页地址 物理地址每次增加 2MB，这是由 26～30 行的内层循环控制，每执行一次外层循环就要执行 512 次内层循环。顶级页目录中第 0 项和第 ((KRNL_VIRTUAL_ADDRESS_START) &gt;&gt; KPML4_SHIFT) &amp; 0x1ff 项，指向同一个页目录指针页，这样的话就能让虚拟地址：0xffff800000000000～0xffff800400000000 和虚拟地址：0～0x400000000，访问到同一个物理地址空间 0～0x400000000，这样做是有目的，内核在启动初期，虚拟地址和物理地址要保持相同。 设置图形模式 void init_graph(machbstart_t* mbsp) &#123; //初始化图形数据结构 graph_t_init(&amp;mbsp->mb_ghparm); //获取VBE模式，通过BIOS中断 get_vbemode(mbsp); //获取一个具体VBE模式的信息，通过BIOS中断 get_vbemodeinfo(mbsp); //设置VBE模式，通过BIOS中断 set_vbemodeinfo(); return; &#125; VBE 是显卡的一个图形规范标准，它定义了显卡的几种图形模式，每个模式包括屏幕分辨率，像素格式与大小，显存大小。调用 BIOS 10h 中断可以返回这些数据结构。 我们选择使用了 VBE 的 118h 模式，该模式下屏幕分辨率为 1024x768，显存大小是 16.8MB。显存开始地址一般为 0xe0000000 屏幕分辨率为 1024x768，即把屏幕分成 768 行，每行 1024 个像素点，但每个像素点占用显存的 32 位数据（4 字节，红、绿、蓝、透明各占 8 位）。我们只要往对应的显存地址写入相应的像素数据，屏幕对应的位置就能显示了。 像素点结构体如下 typedef struct s_PIXCL &#123; u8_t cl_b; //蓝 u8_t cl_g; //绿 u8_t cl_r; //红 u8_t cl_a; //透明 &#125;__attribute__((packed)) pixcl_t; #define BGRA(r,g,b) ((0|(r&lt;&lt;16)|(g&lt;&lt;8)|b)) //通常情况下用pixl_t 和 BGRA宏 typedef u32_t pixl_t; 像素点和显存位置对应如下 u32_t* dispmem = (u32_t*)mbsp->mb_ghparm.gh_framphyadr; dispmem[x + (y * 1024)] = pix; //x，y是像素的位置 连结操作 void init_bstartparm() &#123; machbstart_t *mbsp = MBSPADR; machbstart_t_init(mbsp); //检查CPU init_chkcpu(mbsp); //获取内存布局 init_mem(mbsp); //初始化内核栈 init_krlinitstack(mbsp); //放置内核文件 init_krlfile(mbsp); //放置字库文件 init_defutfont(mbsp); init_meme820(mbsp); //建立MMU页表 init_bstartpages(mbsp); //设置图形模式 init_graph(mbsp); return; &#125; 显示logo void logo(machbstart_t* mbsp) &#123; u32_t retadr=0,sz=0; //在映像文件中获取logo.bmp文件 get_file_rpadrandsz(\"logo.bmp\",mbsp,&amp;retadr,&amp;sz); if(0==retadr) &#123; kerror(\"logo getfilerpadrsz err\"); &#125; //显示logo文件中的图像数据 bmp_print((void*)retadr,mbsp); return; &#125; void init_graph(machbstart_t* mbsp) &#123; //……前面代码省略 //显示 logo(mbsp); return; &#125; logo为24位位图文件 在图格式的文件中，除了文件头的数据就是图形像素点的数据，只不过 24 位的位图每个像素占用 3 字节，并且位置是倒排的，即第一个像素的数据是在文件的最后，依次类推。我们只要依次将位图文件的数据，按照倒排次序写入显存中，这样就可以显示了 把二级引导器的文件和 logo 文件打包成映像文件，然后放在虚拟硬盘中。复制文件到虚拟硬盘中得先 mount，然后复制，最后转换成 VDI 格式的虚拟硬盘，再挂载到虚拟机上启动就行了。这也是为什么要手动建立硬盘的原因，打包命令如下 lmoskrlimg -m k -lhf initldrimh.bin -o Cosmos.eki -f initldrsve.bin initldrkrl.bin font.fnt logo.bmp 进入OS调用 Cosmos 第一个 C 函数之前，我们依然要写一小段汇编代码，切换 CPU 到长模式，初始化 CPU 寄存器和 C 语言要用的栈。因为目前代码执行流在二级引导器中，进入到 Cosmos 中这样在二级引导器中初始过的东西都不能用了。因为 CPU 进入了长模式，寄存器的位宽都变了，所以需要重新初始化 [section .start.text] [BITS 32] _start: cli mov ax,0x10 mov ds,ax mov es,ax mov ss,ax mov fs,ax mov gs,ax lgdt [eGdtPtr] ;开启 PAE mov eax, cr4 bts eax, 5 ; CR4.PAE &#x3D; 1 mov cr4, eax mov eax, PML4T_BADR ;加载MMU顶级页目录 mov cr3, eax ;开启 64bits long-mode mov ecx, IA32_EFER rdmsr bts eax, 8 ; IA32_EFER.LME &#x3D;1 wrmsr ;开启 PE 和 paging mov eax, cr0 bts eax, 0 ; CR0.PE &#x3D;1 bts eax, 31 ;开启 CACHE btr eax,29 ; CR0.NW&#x3D;0 btr eax,30 ; CR0.CD&#x3D;0 CACHE mov cr0, eax ; IA32_EFER.LMA &#x3D; 1 jmp 08:entry64 [BITS 64] entry64: mov ax,0x10 mov ds,ax mov es,ax mov ss,ax mov fs,ax mov gs,ax xor rax,rax xor rbx,rbx xor rbp,rbp xor rcx,rcx xor rdx,rdx xor rdi,rdi xor rsi,rsi xor r8,r8 xor r9,r9 xor r10,r10 xor r11,r11 xor r12,r12 xor r13,r13 xor r14,r14 xor r15,r15 mov rbx,MBSP_ADR mov rax,KRLVIRADR mov rcx,[rbx+KINITSTACK_OFF] add rax,rcx xor rcx,rcx xor rbx,rbx mov rsp,rax push 0 push 0x8 mov rax,hal_start ;调用内核主函数 push rax dw 0xcb48 jmp $ [section .start.data] [BITS 32] x64_GDT: enull_x64_dsc: dq 0 ekrnl_c64_dsc: dq 0x0020980000000000 ; 64-bit 内核代码段 ekrnl_d64_dsc: dq 0x0000920000000000 ; 64-bit 内核数据段 euser_c64_dsc: dq 0x0020f80000000000 ; 64-bit 用户代码段 euser_d64_dsc: dq 0x0000f20000000000 ; 64-bit 用户数据段 eGdtLen equ $ - enull_x64_dsc ; GDT长度 eGdtPtr: dw eGdtLen - 1 ; GDT界限 dq ex64_GDT 1～11 行表示加载 70～75 行的 GDT，13～17 行是设置 MMU 并加载在二级引导器中准备好的 MMU 页表，19～30 行是开启长模式并打开 Cache，34～54 行则是初始化长模式下的寄存器，55～61 行是读取二级引导器准备的机器信息结构中的栈地址，并用这个数据设置 RSP 寄存器。 最关键的是 63～66 行，它开始把 8 和 hal_start 函数的地址压入栈中。dw 0xcb48 是直接写一条指令的机器码——0xcb48，这是一条返回指令。这个返回指令有点特殊，它会把栈中的数据分别弹出到 RIP，CS 寄存器，这正是为了调用我们 os 的第一个 C 函数 hal_start。 小结211、返回到bstartparm.c 调用了chkcpmm.c的init_bstartpages 12、然后调用到了fs.c的move_krlimg函数申请了内存，建立了MMU页表： 顶级页目录，开始于0x1000000 页目录指针目录，开始于0x1001000，，共16项 ，其中每一项都指向一个页目录 页目录，开始于0x1002000， 每页指向512 个物理页，每页2MB【 0x200000】 让物理地址p[0]和虚拟地址p[((KRNL_VIRTUAL_ADDRESS_START) &gt;&gt; KPML4_SHIFT) &amp; 0x1ff]，指向同一个页目录指针页，确保内核在启动初期，虚拟地址和物理地址要保持相同 没搞清楚为什么虚拟地址是这个，也暂时没搞清楚为何要指向(u64_t)((u32_t)pdpte | KPML4_RW | KPML4_P) 最后，把页表首地址保存在机器信息结构中 13、返回到bstartparm.c 调用了graph.c的init_graph A、初始化了数据结构 B、调用init_bgadevice 首先获取GBA设备ID 检查设备最大分辨率 设置显示参数，并将参数保存到mbsp结构中 C、如果不是图形模式，要通过BIOS中断进行切换，设置显示参数，并将参数保存到mbsp结构中： 获取VBE模式，通过BIOS中断 获取一个具体VBE模式的信息，通过BIOS中断 设置VBE模式，通过BIOS中断 这三个方法同样用到了realadr_call_entry，调用路径与上面_getmmap类似，不再展开 D、初始化了一块儿内存 感觉会与物理地址与虚拟地址之间转换由一定关系 E、进行logo显示 调用get_file_rpadrandsz定位到位图文件 调用bmp_print，读入像素点，BGRA转换 最后调用write_pixcolor，写入到mbsp-&gt;mb_ghparm正确的位置，图像就显示出来了 14、然后一路返回 到bstartparm.c的init_bstartparm 到ldrkrlentry.c的ldrkrl_entry 到ldrkrl32.asm的call ldrkrl_entry 再往下是jmp 0x2000000 这个地址就是IMGKRNL_PHYADR，就是刚才放Cosmos.eki的位置","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://blog.innnovation.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://blog.innnovation.cn/tags/OS/"}]},{"title":"火绒安全一面病毒样本分析","slug":"火绒安全一面病毒样本分析","date":"2021-03-15T04:01:00.000Z","updated":"2021-06-25T14:41:13.003Z","comments":true,"path":"2021/03/15/huo-rong-an-quan-yi-mian-bing-du-yang-ben-fen-xi/","link":"","permalink":"https://blog.innnovation.cn/2021/03/15/huo-rong-an-quan-yi-mian-bing-du-yang-ben-fen-xi/","excerpt":"","text":"Summary ： 病毒高危行为： 请求一系列加密的未知IP的443端口，连接可能与其他恶意软件通讯;尝试HTTP但是全都失败了 使用了大量的微软提供的加密函数，已知是AES对称加密 过程中怀疑使用了代码混淆 存在多处绕检测，反调试行为：比如频繁分配内存调用native方法，存在用另一个用户开启线程；多处使用了RDTSC指令来比对执行时间检测虚拟化或反调试；存在大量延迟尝试绕检测；存在LdrLoadDll动态调用绕检测；可能读取PEB信息检测调试器；修改token权限 MD5 974d669e861896a0ebd61c7f2d6e8729 SHA-1 3166a8b05fab2c455586e717210bdf1dad621fc1 SHA-256 b00e7f74539cf39940c9044b6ac1d131a23c896c7905d71a087a01245232ada3 Vhash 0150366d556”z Authentihash 85badbaa56eef4169eb3c0127d9dace88a0b65b5965ad5a146a3477ab38914d4 SSDEEP 3072:9Wql7iWCRq3JV0npTvzY7hEsZNhh8J3Wn:9DNiWn52k7hEsBh TLSH T1B8D3490AE7D782B1FE9601B0167EB73F997152216B159EC3C7A01C20AD512E3A33E76D File type Win32 EXE Magic PE32 executable for MS Windows (GUI) Intel 80386 32-bit 调试过程logs查完文件基本信息之后发现不是常见的vc/C++程序,直接拉到OD里面跑起来,试了一下平时用的一些脱壳方法完全不凑效,发现该程序的PE比较奇怪导入和导出表地址均为0, 于是开始单步调试大法 程序一定需要运行时动态加载未加载完的dll,所以我打开内存映射窗口,看着主窗口,一遍单步一遍观察内存情况同时适当的跳过一些未知的加密循环,光标所在行的上一个call eax为Sleep大约3秒然后光标处加载剩余dll(function0040C2F0),随后马上进入一个Function 00416870, Function 00416870大概应该可以确定是程序的主体逻辑了.(本来尝试过dump 但是dump之后还是无法运行 大概是动态解密的关系吧) 进来16870之后是一个包含大量Sleep，获取CPU时钟相关API的函数，除此之外还有一个子调用，其中主要功能大概为遍历某个文件夹下的所有文件 随后经过一系列Sleephe GetTickCount，再后面看到几个消息处理的API一直到RtlAddVectoredExceptionHandler。然后出现一个子调用call Function 405B30 进入之后看到上面有几个子调用然后出现一个ConvertStringSecurityDescriptorToSecurityDescriptorW CreateMutexW 查阅MSDN之后，前者通常用于转换安全描述符，结合后面的CreateMutexW打开或者创建互斥量可以得出，这段代码大概率是在打开与当前病毒进程文件同名的信号互斥量，判断信号互斥量是否存在，防止病毒行为的二次执行。 那么我大胆推测病毒的主要功能就在这个代码的上方，结合ida的F5 我认为Function0041C6E0（v3 = mainfunction((int)v17, 0);） 包含了大量逻辑 v3 = mainfunction((int)v17, 0); v4 = 1; if ( !v3 ) { sub_4121B0(v16, 50); if ( ConvertStringSecurityDescriptorToSecurityDescriptorW(v16, 1, &amp;v10, 0) ) { v11 = v15; } else { v10 = 0; v11 = 0; } v5 = sub_41A120(); v15[0] = 12; v15[2] = 0; LODWORD(v13) = -1640531527 * v5; HIDWORD(v13) = -1640531527 * sub_41A120(); v15[1] = v10; v14 = sub_403020(v17, 2 * v2, v13, HIDWORD(v13)); if ( dword_41F138(&amp;v13, &amp;v12) &lt; 0 ) { sub_4121B0(v17, 119); sub_401CB0(v17, 128, v17, v13, v14); v12 = v17; } v6 = sub_4121B0(v16, 27); sub_41DD90((char *)v16 + 2 * v6, v12, 100); v7 = createMute(v11, 1, v16); *this = v7; if ( v10 ) { localFree(v10); v7 = *this; } if ( !v7 || (v8 = getLastError(), v4 = 1, v8 != 183) ) v4 = 0; } return v4; 进入这个函数 发现非常非常的长，再逐行分析的话非常不容易，于是我查找所有的模块间调用同时查找所有模块中的名称，查看一下是否有一些敏感的api调用。 以下为我整理的可疑函数： 加密： 00406D10 CryptAcquireContextW,CryptImportKey,CryptSetKeyParam,CryptSetKeyParam,CryptDecrypt,CryptReleaseContext,CryptDestroyKey 0040E760 CryptAcquireContextW,CryptCreateHash,CryptHashData,CryptGetHashParam,CryptGetHashParam,CryptDestroyHash,CryptReleaseContext 0041A890 CryptStringToBinaryW,CryptStringToBinaryW 0040E300 CryptBinaryToStringW,CryptBinaryToStringW 网络：（函数在OD 中并没有执行 可能是因为检测到调试器吧？unsure ） 00415C80 WSAStartup WSACleanup HeapCreate GetProcessHeap RtlAllocateHeap FreeAddrInfoW getaddrinfo FreeAddrInfoW RtlFreeHeap 004067A0 GetCurrentProcess,OpenProcessToken,LookupPrivilegeValueW,AdjustTokenPrivileges,FindCloseChangeNotification 00407870 GetCurrentProcess,OpenProcessToken,LookupPrivilegeValueW,AdjustTokenPrivileges,RevertToSelf,DuplicateTokenEx,CloseHandle,AdjustTokenPrivileges,CloseHandle 0040DB40 GetStartupInfoW,GetCurrentProcess,OpenProcessToken,LookupPrivilegeValueW,AdjustTokenPrivileges,OpenProcess,OpenProcessToken,GetTokenInformation,AllocateAndInitializeSid,EqualSid,OpenProcessToken,RevertToSelf,DuplicateTokenEx,GetTokenInformation,GetTokenInformation,LookupAccountSidW,CreateProcessAsUserW,GetLastError,CloseHandle,CloseHandle,CloseHandle,AdjustTokenPrivileges,CloseHandle 0040BFB0 GetCurrentProcess,OpenProcessToken,LookupPrivilegeValueW,AdjustTokenPrivileges,CloseHandle, 可能的 反调试，绕检测： 004021A0 RtlReAllocateHeap,NtDelayExecution,NtDelayExecution, 0041C6E0 NtQuerySstemInformation,NtQueryObject,GetCurrentProcess,NtQuerySystemInformation,OpenProcess,DuplicateHandle,NtQueryObject,NtQueryObject,NtQueryObject,FindCloseChangeNotification,FindCloseChangeNotification（CheckRemoteDebuggerPresent中会调用NtQueryInformationProcess函数） 004116E0 GetProcAddress,NtQueryInformationProcess 00408810 rdtsc 通过统计时间，判断当前环境是否是虚拟 0041B7A0 GetAdaptersInfo,GetAdaptersInfo 获取网络适配器信息 0040B4D0 LdrLoadDll,未公开的内核调用加载dll 大量的延迟函数： 419FD0 Sleep 4021D6 NtDelayExecution 403643 Sleep 4021D6 NtDelayExecution 4021D6 NtDelayExecution 408416 Sleep 4171A8 Sleep 4021D6 NtDelayExecution 可能用另一个用户启动线程： 0040DB40 GetStartupInfoW,GetCurrentProcess,OpenProcessToken,LookupPrivilegeValueW,AdjustTokenPrivileges,OpenProcess,OpenProcessToken,GetTokenInformation,AllocateAndInitializeSid,EqualSid,OpenProcessToken,RevertToSelf,DuplicateTokenEx,GetTokenInformation,GetTokenInformation,LookupAccountSidW,CreateProcessAsUserW,GetLastError,CloseHandle,CloseHandle,CloseHandle,AdjustTokenPrivileges,CloseHandle, 动态调用api ： 00405940 LoadLibraryW,GetProcAddress, 程序大致流程和逻辑 设置了一个计时器和消息处理，然后创建了heap，在最下面的if出call 405b30 来到405b30 遍历完目录之后进入41c6e0 综合上述信息可得v117的结果应该是通过rdtsc测量时间来检测虚拟化 那么从125行到172行一定是具体检测的逻辑，对于具体怎么测量我不是很清楚 变量v5处再次调用41a120应该是测量前后两次时间差作比较的 接下来又出现3个子调用 第一个 4195a0 408c30 存在循环和位运算，和上一个函数的入参密码相关 第二个 打开句柄调整token权限 第三个 408810是之前的rdtsc指令，getTickCount上下都存在多个rdtsc 执行完第三个函数之后的变量v106和v117存在大量相似的计算和比较 V106还额外执行了上图的3个函数，结合逻辑可以得出上述的推测应该是正确的，即通过106和117获取检测虚拟化，同时在第一个调用处尝试隐藏一些信息（4195a0每次进入循环虚拟机就卡死了，不知道具体是在做什么样的加密） 接下来到label58 4148c0 执行到返回 中间又是包含一堆数学计算 然后出现一个入参包括v24，即上面计算结果的一个复制对象句柄函数 进入41a120之后发现又是一堆rdtsc和位运算 跟v69执行同样的操作在下面还有个v72=sub_41a120(); 函数结尾处 停止监视通知更改句柄 该函数执行完后if判断通过 V7后面的操作应该就是判断是否重复执行了，所以该函数分析结束 返回到外层函数 40e940 生成sid 判断sid相等 40e5d0 StrStrlW GetSystemDirectoryW 大致逻辑下图 其中的41A840 返回a1不超过a2的第一个0地址 8460函数里面逻辑比价复杂 总体上应该就是一个获取目录比较确定目录同时包含加密解密的过程 在Function 00416870函数主体中一路分析 直到此处 发现第一个网络连接httpAPiCalled，具体调用时数据如下图 跟进dword_41f044的函数看到出现了http相关的api 可以推测这个函数所在的循环 会循环请求ip地址列表中的ip，由于没有网络安全方面的工具，无法检测目标ip的安全性 继续调试 这个函数明显发送了请求 并 且返回了请求失败 我在httpcall的地方留了断电 ，F9直接发现了第二个尝试请求的ip 继续F9 我在realrequest的地方F9至少等待了5次以上，不清楚这个 于是我打开wireshark对目标ip进行监视 192.168.88.135 51.77.112.255 TCP 66 49942 → 443 [SYN] Seq=0 Win=64240 Len=0 MSS=1460 WS=256 SACK_PERM=1 关于其连接知道的信息只有这么多了，未知的具体网络行为","categories":[{"name":"逆向分析","slug":"逆向分析","permalink":"https://blog.innnovation.cn/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://blog.innnovation.cn/tags/%E9%80%86%E5%90%91/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://blog.innnovation.cn/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}]},{"title":"逆向工程学习录——Detour / Hook Functions","slug":"Detour  Hook Functions","date":"2020-12-28T23:12:00.000Z","updated":"2021-06-07T16:21:44.648Z","comments":true,"path":"2020/12/29/detour-hook-functions/","link":"","permalink":"https://blog.innnovation.cn/2020/12/29/detour-hook-functions/","excerpt":"","text":"在游戏逆向中我们需要在某个执行函数的地方添加自己的代码。案例：HackMe.exe 每按一次空格扣两滴血目标：hook扣血函数，改为double加血拉进Od后定位到扣血的函数如下图 00BB2740 55 push ebp 00BB2741 8BEC mov ebp,esp 00BB2743 81EC CC000000 sub esp,0xCC 00BB2749 53 push ebx 00BB274A 56 push esi ; HackMe. 00BB274B 57 push edi ; HackMe. 00BB274C 51 push ecx ; HackMe. 00BB274D 8DBD 34FFFFFF lea edi,dword ptr ss:[ebp-0xCC] 00BB2753 B9 33000000 mov ecx,0x33 00BB2758 B8 CCCCCCCC mov eax,0xCCCCCCCC 00BB275D F3:AB rep stos dword ptr es:[edi] 00BB275F 59 pop ecx ; kernel32.771F6359 00BB2760 894D F8 mov dword ptr ss:[ebp-0x8],ecx ; HackMe. 00BB2763 8B45 F8 mov eax,dword ptr ss:[ebp-0x8] 00BB2766 8B08 mov ecx,dword ptr ds:[eax] 00BB2768 2B4D 08 sub ecx,dword ptr ss:[ebp+0x8] 00BB276B 8B55 F8 mov edx,dword ptr ss:[ebp-0x8] 00BB276E 890A mov dword ptr ds:[edx],ecx ; HackMe. 00BB2770 8B45 F8 mov eax,dword ptr ss:[ebp-0x8] 00BB2773 8338 00 cmp dword ptr ds:[eax],0x0 00BB2776 7F 07 jg short HackMe.00BB277F 00BB2778 8B45 F8 mov eax,dword ptr ss:[ebp-0x8] 00BB277B C640 08 01 mov byte ptr ds:[eax+0x8],0x1 00BB277F 5F pop edi ; kernel32.771F6359 00BB2780 5E pop esi ; kernel32.771F6359 00BB2781 5B pop ebx ; kernel32.771F6359 00BB2782 8BE5 mov esp,ebp 00BB2784 5D pop ebp ; kernel32.771F6359 00BB2785 C2 0400 retn 0x4 地址00BB2768 sub ecx,dword ptr ss:[ebp+0x8]我们想要把该指令改为jmp [ourFunc]然后在ourFunc中在jmp回来。 代码实现 #include bool Hook(void* toHook, void* ourFunct, int len) &#123; if (len &lt; 5) &#123; return false; &#125; DWORD curProtection; VirtualProtect(toHook, len, PAGE_EXECUTE_READWRITE, &amp;curProtection); memset(toHook, 0x90, len); DWORD relativeAddress = ((DWORD)ourFunct - (DWORD)toHook) - 5; *(BYTE*)toHook = 0xE9; *(DWORD*)((DWORD)toHook + 1) = relativeAddress; DWORD temp; VirtualProtect(toHook, len, curProtection, &amp;temp); return true; &#125; DWORD jmpBackAddy; void __declspec(naked) ourFunct() &#123; __asm &#123; add ecx, ecx mov edx, [ebp - 8] jmp[jmpBackAddy] &#125; &#125; DWORD WINAPI MainThread(LPVOID param) &#123; int hookLength = 6; DWORD hookAddress = 0xBB2768; jmpBackAddy = hookAddress + hookLength; Hook((void*)hookAddress, ourFunct, hookLength); while (true) &#123; if (GetAsyncKeyState(VK_ESCAPE)) break; Sleep(50); &#125; FreeLibraryAndExitThread((HMODULE)param, 0); return 0; &#125; BOOL WINAPI DllMain(HINSTANCE hModule, DWORD dwReason, LPVOID lpReserved) &#123; switch (dwReason) &#123; case DLL_PROCESS_ATTACH: CreateThread(0, 0, MainThread, hModule, 0, 0); break; &#125; return TRUE; &#125; 由于jmp指令最少占5字节，所以我们必须覆写连同目标指令下一条指令连起来为6字节 运行HackMe 并注入dll跳转成功","categories":[{"name":"逆向分析","slug":"逆向分析","permalink":"https://blog.innnovation.cn/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://blog.innnovation.cn/tags/%E9%80%86%E5%90%91/"},{"name":"Detour Hook","slug":"Detour-Hook","permalink":"https://blog.innnovation.cn/tags/Detour-Hook/"}]},{"title":"记一次用python做的多元线性回归分析","slug":"python多元线性回归分析","date":"2020-01-23T20:47:00.000Z","updated":"2021-06-08T02:10:30.854Z","comments":true,"path":"2020/01/24/python-duo-yuan-xian-xing-hui-gui-fen-xi/","link":"","permalink":"https://blog.innnovation.cn/2020/01/24/python-duo-yuan-xian-xing-hui-gui-fen-xi/","excerpt":"","text":"相关背景调查分析某鱼主播收到付费礼物收入和免费礼物收入模型如下： ; 抓取数据主播相关信息 主播名,主播编号,礼物总收入,付费礼物收入,免费礼物收入,礼物人数,弹幕人数,直播时长,人气峰值,订阅变化,活跃观众,订阅数,抓取时间,直播类型 弹幕相关信息 主播编号,用户名,用户id,用户全站等级,是否粉丝弹幕标记,徽章昵称,用户粉丝等级,弹幕内容,抓取时间,cid 清洗转换数据根据模型要求，从弹幕数据中计算出所需自变量的值合并到主播相关信息中并做简单清洗工作 import pandas as pd import numpy as np import re import os DataDF = pd.read_csv('清洗数据.csv',encoding = \"utf-8\",dtype = str) streamerId=DataDF['主播编号'] paidGiftIncome=np.log(DataDF['付费礼物收入'].astype(float)) freeGifgIncome=np.log(DataDF['免费礼物收入'].astype(float)) subscribeNum=np.log(DataDF['订阅数'].astype(int)) fansNum=np.log(DataDF['活跃观众'].astype(int)) streamType=DataDF['直播类型'].astype(int) topHot=np.log(DataDF['人气峰值'].astype(int)) userLevelVariance=[] fansLevelVariance=[] fansBarrageNum=[] nfansBarrageNum=[] path = 'danmu/' files=[] for f in DataDF['主播编号']: file=f+'.csv' files.append(file) df=pd.read_csv(path+file,encoding='utf-8',dtype=str,keep_default_na=False) dupDf=df.drop_duplicates('用户id','last') userLevelVariance.append(np.var(dupDf['用户全站等级'].astype(int))) fansLevelVariance.append(np.var(dupDf['用户粉丝等级'].astype(float))) mid=np.median(dupDf['用户全站等级'].astype(int)) fansBarrageNum.append(np.log(df[(df['用户全站等级'].astype(int)>= mid )].size)) nfansBarrageNum.append(np.log(df[(df['用户全站等级'].astype(int)&lt; mid )].size)) dataframe = pd.DataFrame(&#123;'主播id':streamerId,'ln关注数':subscribeNum,'ln粉丝数':fansNum,'直播类型':streamType,'ln人气峰值':topHot,'用户等级方差':userLevelVariance,'粉丝等级方差':fansLevelVariance,'ln(粉丝弹幕数量)':fansBarrageNum,'ln(非粉丝弹幕数量)':nfansBarrageNum,'收费礼物收入':paidGiftIncome,'免费礼物收入':freeGifgIncome&#125;) dataframe.to_csv(\"data.csv\",index=False,sep=',') 回归分析讲导出的data文件作为数据全集，划分数据集后使用sklearn进行回归分析 最佳拟合线:截距 [-4.6001933 -2.76872536] ,回归系数： [[-0.46457999 0.85992775 0.96507715 0.59494828 0.02850018 0.00734763-0.10940398 0.17530741][-0.01520268 0.93765167 0.14050881 -0.02137043 0.00608183 -0.022550790.3406813 -0.27023856]] import pandas as pd import numpy as np import seaborn as sns import matplotlib.pyplot as plt from pandas import DataFrame,Series from sklearn.model_selection import train_test_split from sklearn.linear_model import LinearRegression df = pd.read_csv('data.csv') newDf = df[['ln关注数','ln粉丝数','直播类型','ln人气峰值','用户等级方差','粉丝等级方差','ln(粉丝弹幕数量)','ln(非粉丝弹幕数量)','收费礼物收入','免费礼物收入']] print('head:',newDf.head(),'\\nShape:',newDf.shape) X= newDf[['ln关注数','ln粉丝数','直播类型','ln人气峰值','用户等级方差','粉丝等级方差','ln(粉丝弹幕数量)','ln(非粉丝弹幕数量)']] Y= newDf[['收费礼物收入','免费礼物收入']] x_train, x_test, y_train, y_test = train_test_split(X, Y, test_size=0.2) plt.rcParams['font.sans-serif']=['STSong'] plt.rcParams['axes.unicode_minus']=False plt.scatter(df.ln人气峰值,df.收费礼物收入,color = 'b',label = \"Exam Data\") plt.xlabel(\"x\") plt.ylabel(\"giftIncome\") plt.show() print(newDf.describe()) print(df[df.isnull()==True].count()) newDf.boxplot() plt.show() print(df.corr()) sns.pairplot(newDf, x_vars=['ln关注数','ln粉丝数','直播类型','ln人气峰值','用户等级方差','粉丝等级方差','ln(粉丝弹幕数量)','ln(非粉丝弹幕数量)'], y_vars=['收费礼物收入','免费礼物收入'],aspect=0.8,kind = 'reg') plt.show() model = LinearRegression() model.fit(x_train,y_train) a = model.intercept_ b = model.coef_ print(\"最佳拟合线:截距\",a,\",回归系数：\",b) score = model.score(x_test,y_test) print(score) Y_pred = model.predict(x_test) print(Y_pred) plt.plot(range(len(Y_pred)),Y_pred,'b',label=\"predict\") plt.show() plt.figure() plt.plot(range(len(Y_pred)),Y_pred,'b',label=\"predict\") plt.plot(range(len(Y_pred)),y_test,'r',label=\"test\") plt.legend(loc=\"upper right\") plt.xlabel(\"自变量\") plt.ylabel('礼物收入') plt.show()","categories":[{"name":"python","slug":"python","permalink":"https://blog.innnovation.cn/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://blog.innnovation.cn/tags/python/"},{"name":"线性回归","slug":"线性回归","permalink":"https://blog.innnovation.cn/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"https://blog.innnovation.cn/categories/Java/"},{"name":"杂项","slug":"杂项","permalink":"https://blog.innnovation.cn/categories/%E6%9D%82%E9%A1%B9/"},{"name":"操作系统","slug":"操作系统","permalink":"https://blog.innnovation.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"逆向分析","slug":"逆向分析","permalink":"https://blog.innnovation.cn/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"},{"name":"python","slug":"python","permalink":"https://blog.innnovation.cn/categories/python/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.innnovation.cn/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.innnovation.cn/tags/Spring/"},{"name":"WebFlux","slug":"WebFlux","permalink":"https://blog.innnovation.cn/tags/WebFlux/"},{"name":"杂项","slug":"杂项","permalink":"https://blog.innnovation.cn/tags/%E6%9D%82%E9%A1%B9/"},{"name":"GIT","slug":"GIT","permalink":"https://blog.innnovation.cn/tags/GIT/"},{"name":"OS","slug":"OS","permalink":"https://blog.innnovation.cn/tags/OS/"},{"name":"逆向","slug":"逆向","permalink":"https://blog.innnovation.cn/tags/%E9%80%86%E5%90%91/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://blog.innnovation.cn/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"},{"name":"Detour Hook","slug":"Detour-Hook","permalink":"https://blog.innnovation.cn/tags/Detour-Hook/"},{"name":"python","slug":"python","permalink":"https://blog.innnovation.cn/tags/python/"},{"name":"线性回归","slug":"线性回归","permalink":"https://blog.innnovation.cn/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"}]}